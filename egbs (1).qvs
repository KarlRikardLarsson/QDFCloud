///$tab Component export

SUB _egbs.componentversions
/**
@version  egbs-components.qvs
Hämtar egbs.components versionnummer och datum
 
@syntax egbs.loadExpressions('$(vG.ImportPath)expressions.qvd','e.')
@syntax egbs.loadExpressions('..\expressions.xlsx','e.')
@param 1 Textstreng. Sökväg till fil som inehåller beräknings uttryck. För excel-blad krävs embedded lables och att uttrycken finns på första fliken. Om filtyp är skilld från qvd, xlsx, xls så antast plain text.
@param 2 Valfri textstreng. Ett prefix som läggs till alla fält i uttryckstabellen, kan jämföras med QUALIFY LOAD.

@var egbs.vL.loadExpression.TableName in Streng. Tabellnamn för expresstabellen. Default är 'egbs.expressions'.
@changelog 2014-03-11 Vegar #39 Skapat sub för internhantering av versioner och ändringsdatum

*/

egbs.componentversions:
LOAD 
    if(rowno()=1,date('2012-01-01', 'YYYY-MM-DD'), date( peek('Release interval (end)') +1 ,'YYYY-MM-DD')) as [Release interval (start)],
    Datum as [Release interval (end)], 
   	Text(Releasenummer) as  Releasenumber,
	Användare as [Released by]
INLINE [
	Releasenummer, Datum, Användare
	1.0, 2013-02-22, Vegar Lie Arntsen
	1.1, 2013-03-12, Vegar Lie Arntsen
	1.2, 2013-03-26, Vegar Lie Arntsen
	1.3, 2013-04-24, Magnus Svanfeldt
	1.4, 2013-04-25, Vegar Lie Arntsen
	1.5, 2013-06-04, Vegar Lie Arntsen 
	1.6, 2013-07-10, Vegar Lie Arntsen
	1.7, 2013-11-05, Vegar Lie Arntsen
	1.8, 2014-02-05, Vegar Lie Arntsen
	1.9, 2014-03-10, Vegar Lie Arntsen
	1.9.1, 2014-03-12, Vegar Lie Arntsen
	1.9.2, 2014-05-07, Magnus Svanfeldt
	2.0, 2014-05-30, Vegar Lie Arntsen
	2.1, 2015-03-24, Vegar Lie Arntsen
	2.2, 2015-03-31, Magnus Svanfeldt
	2.3, 2015-10-15, Magnus Svanfeldt
	2.4, 2016-08-25, Vegar Lie Arntsen
	3.0, 2016-11-14, Vegar Lie Arntsen
	3.1, 2016-11-25, Vegar Lie Arntsen
	3.1.1, 2016-11-27, Vegar Lie Arntsen
	3.1.2, 2016-11-27, Vegar Lie Arntsen
	3.1.3, 2017-04-21, Vegar Lie Arntsen
	4.0, 2018-07-30, Vegar Lie Arntsen
	4.1, 2019-03-25, Vegar Lie Arntsen
	4.2, 2022-01-20, Magnus Svanfeldt
	4.3, 2022-11-09, Magnus Svanfeldt
]
;


LET egbs.vG.GlobalVersion = peek('Releasenumber');
ENDSUB
CALL _egbs.componentversions
DROP Table egbs.componentversions;
REM ===== avsluta egbs-components.qvs export =====;
///$tab egbs.Calendar

REM ===== starta egbs-components.qvs export =====;

REM
Change Log
===========

Date		User				Description
----------------------------------------------------------------------------
2013-03-12	Vegar Lie Arntsen	La till _prefix på alla tabellfält 
2013-06-04 	Vegar Lie Arntsen  	Issue #21 och #20 Lagt till Fältkommentarer och taggat alla dimensionsfält som dimension.
2015-03-31	Magnus Svanfeldt	Lagt test av kalenderfunktioner i egna funktioner.
								Tagit bort bortkommenterad kod 
								Rensade bort kommentarstaggarna på kalenderfälten, samt rensat i koden
2018-07-26	Vegar Lie Arntsen	Lyft inn funktioner och subbar från egbs-verktyg som behövs för att köra egbs.calendar självständigt
2022-01-20	Magnus Svanfeldt	Anpassat funktionerna egbs.StoreQvd och egbs.ListOutputFile att hantera LIB-sökvägar för Qlik Sense.
2022-11-09	Magnus Svanfeldt	Lagt till två kalendervariabler för SET av år.
;
SUB _egbs.calendar.GetMinMax (_returvariabel, _falt, _kalltabell)
/**
@version  egbs-getminmax.qvs
Hamtar min och max-varden fraan tabell, qvd eller textfil. 

@syntax CALL egbs.GetMinMax('vStats', 'LastUpdate', ['Transactions.qvd']);

@param 1 String. Stomnamn paa variabler som ska returneras.  Variablerna Stomnamn.Max och  Stomnamn.Min kommer bli skapad.
@param 2 String. Faltnamn
@param 3 String, Valfri. Kalla som inehÃ¥ller faltet. Om kalltabellen ar en qvd-fil lases den, annars antas att kallan ar en RESIDENT tabell. Om parametern ar utesluten, anvands varden pÃ¥ frÃ¥n alla fÃ¶rekomster av faltet.

@var *.Min ut Minsta vardet i faltet
@var *.Min ut Hogsta vardet i faltet

@changelog 2016-11-14 Vegar andrar till snabbare metod som loopar paa faltvarden
@changelog 2016-11-15 Vegar Ändrar ä, ö och å i scriptkoden mer internationella tecken som kan lasas i med flere encodings
@changelog 2019-02-04 Vegar Bugfix: Droppar temptabell som används om _kalltabell är angett.
*/

	LET _prefix = ;
	IF QvdCreateTime('$(_kalltabell)') THEN //QVD-fil	
		LET _prefix = '_egbs.'&QvdTableName('$(_kalltabell)')&'.';
	
		_egbstemp.temptab:
		LOAD 
			[$(_falt)] as [$(_prefix)$(_falt)]
		FROM 
			'$(_kalltabell)' (qvd)
		;
			
	ELSEIF	NoOfRows('$(_kalltabell)') > 0 then  //om resuident specifik tabell
		LET _prefix = '_egbs.$(_kalltabell).';
		_egbstemp.temptab:
		LOAD 
			[$(_falt)] as [$(_prefix)$(_falt)]
		Resident 
			[$(_kalltabell)]
		;
	
	ELSEIF len('$(_kalltabell)') > 0 THEN //Kalltabell angivet, men fÃ¥r inte traff ovan.
	 	TRACE ## WARNING: _egbs.calendar.GetMinMax('$(_returvariabel)', '$(_falt)', '$(_kalltabell)');
	 	TRACE             '$(_kalltabell)' ar ingen giltig tabell eller qvd-fil. Hämtar min/max från alla fältvärden.;
	ENDIF  
	MinMax:
	Load
			Min([$(_prefix)$(_falt)]) as  _egbstemp.minval,
			Max([$(_prefix)$(_falt)]) as _egbstemp.maxval
		;
		Load
			FieldValue( '$(_prefix)$(_falt)', IterNo()) as [$(_prefix)$(_falt)]
		Autogenerate(1)
		While 
			NOT IsNull(FieldValue('$(_prefix)$(_falt)', IterNo()))
		;
	if not isnull(TableNumber('_egbstemp.temptab')) then
 		drop table _egbstemp.temptab;
	end if


	LET $(_returvariabel).Max = replace(peek('_egbstemp.maxval'), ',', '.');
	LET $(_returvariabel).Min = replace(peek('_egbstemp.minval'), ',', '.');
	Drop table MinMax;
	LET _prefix=;
ENDSUB //_egbs.calendar.getminmax

///$tab _egbs.calendar.setEmptyVariable
SUB _egbs.calendar.setEmptyVariable(_var, _default)
	/**
	@version egbs-verktyg.qwv $Revision$  $Author$
	Sätter defaultvärde på variabel så länge den inte är förhandsdefinierad i scriptet t.ex via språk/anpassnings-includes.
	@syntax CALL _egbs.calendar.setEmptyVariable('Var1', 'Defaultvärde 1')
	@param 1 Textstreng. Namn på variabel som ska sättas värde på. 
	@param 2 Textstreng. Defaultvärdet på variabeln.
	@var <Parameter 1> ut Returnerar variabeln deklarerad som paramteter 1 med befintligt eller defaultvärde

	*/
	LET $(_var) = if(len($(_var))=0, _default, $(_var));
ENDSUB

SUB egbs.Calendar(_minDate, _maxDate, _DateKeyField, _prefix)
/**	
@version  egbs-kalender.qvs
Skapa en kalendertabell 

Det finns möjlighet att skapa egbs.calendar set variablerna vL.Set.xxx och vL.Set.xxx.Modifier som innehåller fullständiga set-uttryck och set-modifiers. 
Setuttrycksvariablerna slås på via variablen egbs.vL.Calendar.CreateSetVariable = -1.

Alla fältnamn i kalendertabellen går att anpassa via variablerna egbs.vL.Calendar.Field.xxx. 

Alla egbs.calendar-specifika variabler kan rensas via anrop till sub egbs.CalendarCleanup.


@syntax CALL egbs.Calendar(vMinDate, vMaxDate, DateIdField)
@syntax CALL egbs.Calendar(40100, 40160, '%ModDatum', 'mod' )
@Param 1 Numerisk $(egbs.vL.Calendar.Field.YearMonth) representation av det datum kalendern ska börja.
@Param 2 Numerisk representation av det datum kalendern sk sluta
@Param 3 Namn på nyckelfält som inehåller heltalsrepresentationen av kalenderdagen.
@Param 4 Valfri. Ett prefix som identifierer både kalendertabell och fältnamn.

@var egbs.vL.YearMonthFormat in Formatering som ska användas för representation av År-månad
@var egbs.vL.Calendar.WeekStartDay in Anger vilken veckodag som veckan ska börja på. Anges med ISO8601-formatet där 1=Mån, 2=Tis, ... , 7=sön. Måndag (1) är default veckostart och ISO8601-standard. 
@var egbs.vL.Calendar.Table.Name in rootnamn på kalendertabell.Om  variabel inte är definierad så används ett defaultnamn på engelska.
@var egbs.vL.Calendar.Field.Date in Namn på fält med dato.Om  variabel inte är definierad så används ett defaultnamn på engelska.
@var egbs.vL.Calendar.Field.Day in Namn på fält med dagnummer.Om  variabel inte är definierad så används ett defaultnamn på engelska.
@var egbs.vL.Calendar.Field.Week in Namn på fält med veckonummer.Om  variabel inte är definierad så används ett defaultnamn på engelska.
@var egbs.vL.Calendar.Field.Weekday in Namn på fält med veckodag Week.Om  variabel inte är definierad så används ett defaultnamn på engelska.
@var egbs.vL.Calendar.Field.YearWeek in Namn på fält med år-vecka Year-Week.Om  variabel inte är definierad så används ett defaultnamn på engelska.
@var egbs.vL.Calendar.Field.YearWeekSerial in Namn på fält med år-veckanummer Year-Week-Serial.Om  variabel inte är definierad så används ett defaultnamn på engelska.
@var egbs.vL.Calendar.Field.Month in Namn på fält med månad Month.Om  variabel inte är definierad så används ett defaultnamn på engelska.
@var egbs.vL.Calendar.Field.YearMonth in Namn på fält med år-månad Year-Month.Om  variabel inte är definierad så används ett defaultnamn på engelska.
@var egbs.vL.Calendar.Field.YearMonthSerial in Namn på fält med år-månadsnummer Year-Month-Serial.Om  variabel inte är definierad så används ett defaultnamn på engelska.
@var egbs.vL.Calendar.Field.Quarter in Namn på fält med kvartal Quarter.Om  variabel inte är definierad så används ett defaultnamn på engelska.
@var egbs.vL.Calendar.Field.Year in Namn på fält med år Year.Om  variabel inte är definierad så används ett defaultnamn på engelska.
@var egbs.vL.Calendar.Field.QuarterName in Namn på fält med kvartalnamn.Om  variabel inte är definierad så används ett defaultnamn på engelska.
@var egbs.vL.Calendar.Field.Tertial in Namn på fält med tertial.Om  variabel inte är definierad så används ett defaultnamn på engelska.
@var egbs.vL.Calendar.Field.TertialName in Namn på fält med tertialnamn.Om  variabel inte är definierad så används ett defaultnamn på engelska.
@var egbs.vL.Calendar.WeekOneReferenceDay in För att hantera vecka 1. Defaultvärde är 4, dvsden 4:e januari är vecka 1 (ISO 8601)
@var egbs.vL.Calendar.BrokenWeeks in A week is always unbroken, i.e. some years week 1 starts already in December, and in other years week 52 or 53 continues into January. (ISO 8601)
@var egbs.vL.Calendar.CreateSetVariables in Variabel som anger om set och set-modifier-uttryck ska skapas. Variablerna skapas inte per default (0). För att skapa variablerna sätt variabeln till (-1)

@var vL.Set.Year ut Ett fullständigt set-uttryck för att göra beräkningar för Year. Variabeln kan användas med parameter för att styra vilket år relativt till maxurval som avses.
@var vL.Set.YTD ut Ett fullständigt set-uttryck för att göra beräkningar för Year To Date. Variabeln kan användas med parameter för att styra vilket år relativt till maxurval som avses.
@var vL.Set.MTD ut Ett fullständigt set-uttryck för att göra beräkningar för Month To Date. Variabeln kan användas med parameter för att styra vilket år relativt till maxurval som avses.
@var vL.Set.QTD ut Ett fullständigt set-uttryck för att göra beräkningar för Quarter To Date. Variabeln kan användas med parameter för att styra vilket år relativt till maxurval som avses.
@var vL.Set.Month ut Ett fullständigt set-uttryck för att göra beräkningar för en specifik månad. Variabeln kan användas med parameter för att styra vilket år relativt till maxurval som avses, -1 anvser föregåemde månad, 1 avser kommande månad.
@var vL.Set.Quarter ut Ett fullständigt set-uttryck för att göra beräkningar för ett specifikt kvartal. Variabeln kan användas med parameter för att styra vilket år relativt till maxurval som avses, -1 anvser föregående kvartal, 1 avser kommande kvartal.
@var vL.Set.RollingMonths ut Ett fullständigt set-uttryck för göra beräkningar på Rullande N månader där N är parameter för hur många månader bakåt i jmf till maxurval som avses. Default är -12 mnd.
@var vL.Set.Year.Modifier ut Set modifier för att göra beräkningar för Year. Variabeln kan användas med parameter för att styra vilket år relativt till maxurval som avses.
@var vL.Set.YTD.Modifier ut Set modifier för att göra beräkningar för Year To Date. Variabeln kan användas med parameter för att styra vilket år relativt till maxurval som avses.
@var vL.Set.MTD.Modifier ut Set modifier för att göra beräkningar för Month To Date. Variabeln kan användas med parameter för att styra vilket år relativt till maxurval som avses.
@var vL.Set.QTD.Modifier ut Set modifier arguments Year To Date, variabeln tar parameter för vilket år relativt till maxurval som avses.
@var vL.Set.Month.Modifier ut Set modifier arguments månad, variabeln tar parameter för vilken månad relativt till maxurval som avses.
@var vL.Set.Quarter.Modifier ut Set modifier arguments Year To Date, variabeln tar parameter för vilket år relativt till maxurval som avses.
@var vL.Set.RollingMonths.Modifier ut En set-modifier för göra beräkningar på Rullande N månader där N är parameter för hur många månader bakåt i jmf till maxurval som avses. Default är -12 mnd.
@var vL.Set.RollingMonthsToDate ut SET för att göra beräkningar på rullande på dagen N månader bakåt i tid. Parameter 1: antal månader (-12 är Rullande12). Parameter 2: förskyvning (-12 = föregående år) 

@changelog 2014-02-05 Vegar #43 La till kriterium att qlikviewversion >= 10 för att tag på kalender ska exekveras.
@changelog 2014-02-05 Vegar #41 Bytte standardnamn på fältnamn, tog bort bindestreck i fältnamn.
@changelog 2014-02-05 Vegar #44 Default årmånad är formaterat som datum
@changelog 2013-04-24 Vegar #15 Parameterordning fixat så att dokumentationen stämmer överrens med funktionen.
@changelog 2013-04-24 Vegar #17 Justerade sökväg så att den blev korrekt.
@changelog 2013-04-25 Vegar #19 Möjlighet att justera vilken veckodag som ska representeras i År-vecka. Styrs ned variabeln  egbs.vL.Calendar.YearWeek.Weekday
@changelog 2013-06-04 Vegar #21 Lagt till Fältkommentarer och taggat alla dimensionsfält som dimension.
@changelog 2013-06-04 Vegar #20 Lagt till Fältkommentarer och taggat alla dimensionsfält som dimension.
@changelog 2014-03-11 Vegar #42 Dynamisk start av vecka. Anges med ISO8601-formatet där 1=Mån, 2=Tis, ... , 7=sön. Måndag (1) är default veckostart och ISO8601-standard.
@changelog 2014-03-20 Vegar EJ BAKÅTKOMPATIBEL Borttag av egbs.vL.Calendar.Weekday.StartDay och egbs.vL.Calendar.Weekday.StartDay. Den slås tillsamman med egbs.vL.Calendar.WeekStartDay som används för att definiera när veckan startar. 
@changelog 2014-03-20 Vegar #68 Möjliggör omdefiniering av veckonummer. Använd variablerna egbs.vL.Calendar.WeekStartDay egbs.vL.Calendar.WeekOneReferenceDay och egbs.vL.Calendar.BrokenWeeks. Default är ISO 8601. Default är egbs.vL.Calendar.WeekStartDay = 1 (måndag)  egbs.vL.Calendar.WeekOneReferenceDay = 4 (4. januari) och  egbs.vL.Calendar.BrokenWeeks = 0 (ej tillåtet)
@changelog 2014-03-20 Vegar #76 Lagt till flaggor för att markera in datum som är i gällande månad, föregående månad, månadsnummeret är i month to date eller quarer to date 
@changelog 2014-05-08 Vegar #76 Tagis bort flaggor som blev implementert 2014-03-20. 
@changelog 2014-05-30 Vegar #92 Åtgärdat bug som gjorde att ÅrMånad kunde visa fel text på enstaka datum i samband med årsbrytningar om man hade inställd annan veckostart än måndagar.
@changelog 2014-05-31 Vegar Rensade bort efterlevnader från egbs.vL.Calendar.YearWeek.Weekday och egbs.vL.Calendar.Weekday.StartDay som fanns i scriptet, men som f.o.m. Version 2.0 saknar funktion.
@changelog 2015-03-31 Magnus Rensade bort kommentarstaggarna på kalenderfälten, samt rensat i koden
@changelog 2016-08-25 Vegar Lade till tertiär
@changelog 2016-11-24 Vegar Lagt till SET-uttryck för Rullande N månader, Year to date, Month to date, Quarter to date, enskilld månad eller kvartal. De är på formatet vL.Set.<setfunktion> för hela set och vL.Set.<setfunktion>.Modifier för endast modifier.
@changelog 2016-11-27 Vegar Möjlighet att slå av skapandet av set-uttryck i klandern med hjälp av egbs.vL.Calendar.CreateSetVariables
@changelog 2016-11-29 Vegar #6 Hantera fel i set samt strukturerat om setvariabelnamnsättningen när prefix är angivet. 
@changelog 2017-04-21 Vegar #12 Utöka setutrycken till kalendern med vL.Set.RollingMonthsToDate så att rullande perioder kan fungera fram till datum och inte enbart månad.
@changelog 2018-07-30 Vegar	Gör egbs-calendar.qvs oberende av andra filer i egbs-components.
@changelog 2019-02-04 Vegar _mindate och _maxdata kan numbera vara datum och inte numerisk representation av datum
@changelog 2022-11-09 Magnus Lagt till SET-uttryck för Year.
*/

	//Sätter Datumnyckelfält, default är %Datumnyckel om inget är angivet
	if len( _DateKeyField)>0 then
		SET egbs.vL.Calendar.Field.DateKey= $(_DateKeyField);
	ELSE 
		SET egbs.vL.Calendar.Field.DateKey = %Datumnyckel;
	ENDIF

	// Kalenderformat
	CALL _egbs.calendar.setEmptyVariable('egbs.vL.YearMonthFormat','YYYY MMM')

	//Benamning på kalenderfält Defaultvärden - Om variablerna inte är definierade så sätt defaultvärden
	CALL _egbs.calendar.setEmptyVariable('egbs.vL.Calendar.Table.Name','Calendar' )
	CALL _egbs.calendar.setEmptyVariable('egbs.vL.Calendar.Field.Date','Date' )
	CALL _egbs.calendar.setEmptyVariable('egbs.vL.Calendar.Field.DateSerial','Date Serial' )
	CALL _egbs.calendar.setEmptyVariable('egbs.vL.Calendar.Field.Day','Day')
	CALL _egbs.calendar.setEmptyVariable('egbs.vL.Calendar.Field.Week','Week')
	CALL _egbs.calendar.setEmptyVariable('egbs.vL.Calendar.Field.Weekday','Weekday')
	CALL _egbs.calendar.setEmptyVariable('egbs.vL.Calendar.Field.YearWeek','Year Week')
	CALL _egbs.calendar.setEmptyVariable('egbs.vL.Calendar.Field.YearWeekSerial','Year Week Serial')
	CALL _egbs.calendar.setEmptyVariable('egbs.vL.Calendar.Field.Month','Month')
	CALL _egbs.calendar.setEmptyVariable('egbs.vL.Calendar.Field.YearMonth','Year Month')
	CALL _egbs.calendar.setEmptyVariable('egbs.vL.Calendar.Field.YearMonthSerial','Year Month Serial')
	CALL _egbs.calendar.setEmptyVariable('egbs.vL.Calendar.Field.Quarter','Quarter')
	CALL _egbs.calendar.setEmptyVariable('egbs.vL.Calendar.Field.Tertial','Tertial')
	CALL _egbs.calendar.setEmptyVariable('egbs.vL.Calendar.Field.TertialName','Tertial Name')
	CALL _egbs.calendar.setEmptyVariable('egbs.vL.Calendar.Field.Year','Year')
	CALL _egbs.calendar.setEmptyVariable('egbs.vL.Calendar.Field.QuarterName','Quarter Name')
	CALL _egbs.calendar.setEmptyVariable('egbs.vL.Calendar.Field.QuarterSerial','Quarter Serial')
	CALL _egbs.calendar.setEmptyVariable('egbs.vL.Calendar.WeekStartDay','1') //The week starts on a Monday.
	CALL _egbs.calendar.setEmptyVariable('egbs.vL.Calendar.WeekOneReferenceDay','4') //Week 1 always contains Jan 4th.(ISO 8601) 
	CALL _egbs.calendar.setEmptyVariable('egbs.vL.Calendar.CreateSetVariables','0')
	CALL _egbs.calendar.setEmptyVariable('egbs.vL.Calendar.BrokenWeeks','0') //A week is always unbroken, i.e. some years week 1 starts already in December, and in other years week 52 or 53 continues into January. (ISO 8601) 


	// Skapar kalender
	[$(_prefix)$(egbs.vL.Calendar.Table.Name)]:
	NOCONCATENATE
	LOAD 
		/*
		
		*/
		num(egbs.Calendar.TempDate) AS [$(egbs.vL.Calendar.Field.DateKey)], //Int id
		num(egbs.Calendar.TempDate) AS [$(_prefix)$(egbs.vL.Calendar.Field.DateSerial)], //Int id
		Date(egbs.Calendar.TempDate) as [$(_prefix)$(egbs.vL.Calendar.Field.Date)], //Dual Datum
		day(egbs.Calendar.TempDate) AS [$(_prefix)$(egbs.vL.Calendar.Field.Day)], //Int Dag(1-31)
		Dual( WeekDay( egbs.Calendar.TempDate ), Mod(WeekDay( egbs.Calendar.TempDate - $(egbs.vL.Calendar.WeekStartDay)+1 ), 7 )+1) AS [$(_prefix)$(egbs.vL.Calendar.Field.Weekday)], 	//Dual Veckodag  //Issue #40
		DUAL(	/*TEXT*/ Year( /*<weekYearDate>*/Date( YearStart( If( $(egbs.vL.Calendar.BrokenWeeks), egbs.Calendar.TempDate, /*<weekdate>*/Date( WeekStart( egbs.Calendar.TempDate, 1, $(egbs.vL.Calendar.WeekStartDay)-1 ) - $(egbs.vL.Calendar.WeekOneReferenceDay) )/*</weekdate>*/ )) + $(egbs.vL.Calendar.WeekOneReferenceDay) - 1)/*</weekYearDate>*/ ) &'/'& Div( egbs.Calendar.TempDate - WeekStart(  /*<weekYearDate>*/Date( YearStart( If( $(egbs.vL.Calendar.BrokenWeeks), [egbs.Calendar.TempDate], /*<weekdate>*/Date( WeekStart( egbs.Calendar.TempDate, 1, $(egbs.vL.Calendar.WeekStartDay) -1) - $(egbs.vL.Calendar.WeekOneReferenceDay) )/*</weekdate>*/ )) + $(egbs.vL.Calendar.WeekOneReferenceDay) - 1)/*</weekYearDate>*/, 0, $(egbs.vL.Calendar.WeekStartDay)-1 ) + 7, 7 ),  
				/*NUM*/ /*<weekdate>*/Date( WeekStart( egbs.Calendar.TempDate, 1, $(egbs.vL.Calendar.WeekStartDay)-1 ) - $(egbs.vL.Calendar.WeekOneReferenceDay) )/*</weekdate>*/
			)  AS [$(_prefix)$(egbs.vL.Calendar.Field.YearWeek)] ,//Dual År-vecka ( Issue #19 )

		AutoNumber(QuarterStart(egbs.Calendar.TempDate),'_QuarterSerial' ) as [$(_prefix)$(egbs.vL.Calendar.Field.QuarterSerial)],
		Div( egbs.Calendar.TempDate - WeekStart(  /*<weekYearDate>*/Date( YearStart( If( $(egbs.vL.Calendar.BrokenWeeks), [egbs.Calendar.TempDate], /*<weekdate>*/Date( WeekStart( egbs.Calendar.TempDate, 1, $(egbs.vL.Calendar.WeekStartDay) -1) - $(egbs.vL.Calendar.WeekOneReferenceDay) )/*</weekdate>*/ )) + $(egbs.vL.Calendar.WeekOneReferenceDay) - 1)/*</weekYearDate>*/, 0, $(egbs.vL.Calendar.WeekStartDay)-1 ) + 7, 7 )  AS [$(_prefix)$(egbs.vL.Calendar.Field.Week)], //Int vecka	

		AutoNumber(WeekName(egbs.Calendar.TempDate),'_YearWeekSerial') as [$(_prefix)$(egbs.vL.Calendar.Field.YearWeekSerial)],
		AutoNumber(MonthName(egbs.Calendar.TempDate), '_month') as [$(_prefix)$(egbs.vL.Calendar.Field.YearMonthSerial)],
		Month(egbs.Calendar.TempDate) AS [$(_prefix)$(egbs.vL.Calendar.Field.Month)],
		dual(date(MonthName(egbs.Calendar.TempDate), '$(egbs.vL.YearMonthFormat)'),MonthStart(egbs.Calendar.TempDate)) AS [$(_prefix)$(egbs.vL.Calendar.Field.YearMonth)],
		Dual('Q'&Ceil(month(egbs.Calendar.TempDate)/3), Ceil(month(egbs.Calendar.TempDate)/3)) as [$(_prefix)$(egbs.vL.Calendar.Field.Quarter)],
		Dual('Q'&Ceil(month(egbs.Calendar.TempDate)/3) & ' ' &Year(egbs.Calendar.TempDate), num(QuarterStart(egbs.Calendar.TempDate)))  as [$(_prefix)$(egbs.vL.Calendar.Field.QuarterName)],
		Dual('T'&Ceil(month(egbs.Calendar.TempDate)/4) & ' ' & Year(egbs.Calendar.TempDate), makedate(Year(egbs.Calendar.TempDate), Ceil(month(egbs.Calendar.TempDate)/4)*4)) as [$(_prefix)$(egbs.vL.Calendar.Field.TertialName)],
		Dual('T'&Ceil(month(egbs.Calendar.TempDate)/4), Ceil(month(egbs.Calendar.TempDate)/4)) as [$(_prefix)$(egbs.vL.Calendar.Field.Tertial)],
		Year(egbs.Calendar.TempDate) AS [$(_prefix)$(egbs.vL.Calendar.Field.Year)]
		;
	LOAD
		Date('$(_minDate)') + RecNo()-1 AS egbs.Calendar.TempDate
	AUTOGENERATE 
		Date('$(_maxDate)') - Date('$(_minDate)') + 1;


	//Tag and comment table fields
	IF subfield(QlikViewVersion(),'.',1) >= 10 then
		FOR each _calendarDimension in 'Week','Weekday','Date', 'Day', 'YearWeek','YearMonth','Month','Quarter','QuarterName','Year', 'TertialName', 'Tertial'
			TAG fields [$(_prefix)$(egbs.vL.Calendar.Field.$(_calendarDimension))] with $dimension;
		NEXT
	ENDIF
	SET _calendarDimension =;

	// Log calendar creation
	LET _calStart = Date($(_minDate));
	LET _calEnd = Date($(_maxDate));
	TRACE # egbs-components: The calendar "$(_prefix)$(egbs.vL.Calendar.Table.Name)" is created with days from $(_calStart) to $(_calEnd) in SUB egbs.Calendar;

	LET _calStart=;
	LET _calEnd=;

	///$tab Calendar Set Variables
	IF $(egbs.vL.Calendar.CreateSetVariables) THEN	// If SA variables requested,

		// Mapping table that will be used to translate escaped special chars
		[_egbs.vL.temp.Calendar.EscapeCharsMap]:
		MAPPING LOAD * INLINE [
		from, to
		@,$
		|,'
		]
		;
		// Tar bort blanksteg och ersätter med _ då vi inte vill ha blanksteg i variabelnamn
		LET _suffixNoSpace = if(len('$(_prefix)')>0,
								if( (len('$(_prefix)') = index('$(_prefix)','.',-1)), //Sista tecknet är punkt
									'.' & replace(mid('$(_prefix)',1,len('$(_prefix)')-1),' ','_'), //Ta bort sista punkten
									'.' & replace('$(_prefix)',' ','_') 
							      ), 
								  replace('$(_prefix)',' ','_')
								);
				
		// Create an indirect name for the runtime variable that will compute the selected calendar fields.
		SET _egbs.vL.Calendar.SelectedFieldList_$(_suffixNoSpace) = _egbs.vL.Calendar.SelectedFieldList_$(_suffixNoSpace);		

		// Create a modifer list of Calendar fields to be used to clear all calendar selections
		SET _egbs.vL.ClearFieldList=;
		FOR _egbs.vL.temp.i = 1 to NoOfFields('$(_prefix)$(egbs.vL.Calendar.Table.Name)')
			LET _egbs.vL.ClearFieldList = '$(_egbs.vL.ClearFieldList)' & '[' & FieldName($(_egbs.vL.temp.i), '$(_prefix)$(egbs.vL.Calendar.Table.Name)') & ']=,';
		NEXT _egbs.vL.temp.i
		SET _egbs.vL.temp.i=;

		//
		// Create a variable expression that will build a modifier list that reflects all current calendar selections
		//
		SET _egbs.vL.Calendar.SelectedFieldList_$(_suffixNoSpace)='=';		// Init variable
		
		SET _egbs.vL.temp.vConcat =;			// Set concat char to empty for first time through loop
		FOR _egbs.vL.temp.i = 1 to NoOfFields('$(_prefix)$(egbs.vL.Calendar.Table.Name)')		// Loop through all fields in Calendar table
			// Get next fieldname in var
			LET _egbs.vL.temp.vFname = FieldName($(_egbs.vL.temp.i), '$(_prefix)$(egbs.vL.Calendar.Table.Name)');
			// Add field to list
			LET _egbs.vL.Calendar.SelectedFieldList_$(_suffixNoSpace) = '$(_egbs.vL.Calendar.SelectedFieldList_$(_suffixNoSpace))'
			& '$(_egbs.vL.temp.vConcat) if(GetSelectedCount([$(_egbs.vL.temp.vFname)])>0, |,[$(_egbs.vL.temp.vFname)]={"|	& GetFieldSelections([$(_egbs.vL.temp.vFname)],|","|,1000) &|"}|, ||)' & chr(10);
			SET _egbs.vL.temp.vConcat ='&';		// Set concat char for next time through loop
		NEXT _egbs.vL.temp.i
		SET _egbs.vL.temp.i=;
		SET _egbs.vL.temp.vFname=;
		SET _egbs.vL.temp.vConcat=;

		// Hantera specialtecken
		LET _egbs.vL.Calendar.SelectedFieldList_$(_suffixNoSpace) = 
		MapSubString('_egbs.vL.temp.Calendar.EscapeCharsMap',
			'$(_egbs.vL.Calendar.SelectedFieldList_$(_suffixNoSpace))'
		);
		// Create a convienence variable we will use to form the variables
		SET _egbs.vL.temp.vMaxModifier = 'Max({1<_egbs.Dummyfield=@(_egbs.vL.Calendar.SelectedFieldList_$(_suffixNoSpace))>}';	

		/* 	Year  */
			Let vL.Set.Year.Modifier$(_suffixNoSpace) = 
			MapSubString('_egbs.vL.temp.Calendar.EscapeCharsMap',
			'$(_egbs.vL.ClearFieldList)
			[$(_prefix)$(egbs.vL.Calendar.Field.Year)] = {"@(=$(_egbs.vL.temp.vMaxModifier)[$(_prefix)$(egbs.vL.Calendar.Field.Year)]) + alt($1,0) )"}'
			);

			Let vL.Set.Year$(_suffixNoSpace) =
			MapSubString('_egbs.vL.temp.Calendar.EscapeCharsMap',
			'{$<
			@(vL.Set.Year.Modifier$(_suffixNoSpace)($1))
			>}'
			);

		/* 	Year To Date */
			Let vL.Set.YTD.Modifier$(_suffixNoSpace) = 
			MapSubString('_egbs.vL.temp.Calendar.EscapeCharsMap',
			'$(_egbs.vL.ClearFieldList)
			[$(_prefix)$(egbs.vL.Calendar.Field.DateSerial)] = {"<=@(=num(addyears($(_egbs.vL.temp.vMaxModifier) [$(_prefix)$(egbs.vL.Calendar.Field.DateSerial)]),  alt($1,0) )))"},
			[$(_prefix)$(egbs.vL.Calendar.Field.Year)] = {"@(=$(_egbs.vL.temp.vMaxModifier)[$(_prefix)$(egbs.vL.Calendar.Field.Year)]) +  alt($1,0) )"}'
			);

			Let vL.Set.YTD$(_suffixNoSpace) =
			MapSubString('_egbs.vL.temp.Calendar.EscapeCharsMap',
			'{$<
			@(vL.Set.YTD.Modifier$(_suffixNoSpace)($1))
			>}'
			);	

		/* 	Month To Date */
			Let vL.Set.MTD.Modifier$(_suffixNoSpace) =
			MapSubString('_egbs.vL.temp.Calendar.EscapeCharsMap',
			'$(_egbs.vL.ClearFieldList)
			[$(_prefix)$(egbs.vL.Calendar.Field.YearMonthSerial)] = {@(=$(_egbs.vL.temp.vMaxModifier) [$(_prefix)$(egbs.vL.Calendar.Field.YearMonthSerial)])+ alt($1,0) )},
			[$(_prefix)$(egbs.vL.Calendar.Field.Day)] = {"<=@(=$(_egbs.vL.temp.vMaxModifier) [$(_prefix)$(egbs.vL.Calendar.Field.Day)]))"}'
			);

			Let vL.Set.MTD$(_suffixNoSpace) = 
			MapSubString('_egbs.vL.temp.Calendar.EscapeCharsMap',
			'{$<
			@(vL.Set.MTD.Modifier$(_suffixNoSpace)($1))
			>}'
			);
			
		/*  Year Quarter To Date */
			Let vL.Set.QTD.Modifier$(_suffixNoSpace) =
			MapSubString('_egbs.vL.temp.Calendar.EscapeCharsMap',
			'$(_egbs.vL.ClearFieldList)
			[$(_prefix)$(egbs.vL.Calendar.Field.QuarterSerial)] =  {@(=Max([$(_prefix)$(egbs.vL.Calendar.Field.QuarterSerial)]) + alt($1,0) )} ,
			[$(_prefix)$(egbs.vL.Calendar.Field.Day)] = {"<=@(=$(_egbs.vL.temp.vMaxModifier) [$(_prefix)$(egbs.vL.Calendar.Field.Day)]))"}'
			);

			Let vL.Set.QTD$(_suffixNoSpace) =
			MapSubString('_egbs.vL.temp.Calendar.EscapeCharsMap',
			'{$<
			@(vL.Set.QTD.Modifier$(_suffixNoSpace)($1))
			>}'
			);

		/* 	Rullande N Months.
			N antal månader jmf med senast valda månad. Default är -12 mnd aka R12.
			Begränsning: endast negativa värden (dvs historik).

		*/
			Let vL.Set.RollingMonths.Modifier$(_suffixNoSpace) =
			MapSubString('_egbs.vL.temp.Calendar.EscapeCharsMap',
			'$(_egbs.vL.ClearFieldList)
			[$(_prefix)$(egbs.vL.Calendar.Field.YearMonthSerial)] = {">=@(=$(_egbs.vL.temp.vMaxModifier) [$(_prefix)$(egbs.vL.Calendar.Field.YearMonthSerial)]) + (  alt($1,-1) + 1)  )<=@(=$(_egbs.vL.temp.vMaxModifier) [$(_prefix)$(egbs.vL.Calendar.Field.YearMonthSerial)]))"}'
			);

			Let vL.Set.RollingMonths$(_suffixNoSpace) =
			MapSubString('_egbs.vL.temp.Calendar.EscapeCharsMap',
			'{$<
			@(vL.Set.RollingMonths.Modifier$(_suffixNoSpace)($1))
			>}'
			);

		/* Rullande N Months To date.
			N antal månader jmf med senast valda datum. Default är -12 mnd aka R12TD.
			Parameter 1: antal månaders historik
			Parameter 2: förskyvning.
			Begränsning: endast negativa värden (dvs historik).

		*/
			Let vL.Set.RollingMonthsToDate.Modifier$(_suffixNoSpace) =
			MapSubString('_egbs.vL.temp.Calendar.EscapeCharsMap',
			'$(_egbs.vL.ClearFieldList)
			[$(_prefix)$(egbs.vL.Calendar.Field.DateSerial)] = 
				{">=@(=num(addmonths($(_egbs.vL.temp.vMaxModifier) [$(_prefix)$(egbs.vL.Calendar.Field.DateSerial)])   ,alt($1,-12) + alt($2,0) ) +1 )) <=@(=num(addmonths($(_egbs.vL.temp.vMaxModifier) [$(_prefix)$(egbs.vL.Calendar.Field.DateSerial)]) ,alt($2,0) ) ))"}'
			);

			Let vL.Set.RollingMonthsToDate$(_suffixNoSpace) =
			MapSubString('_egbs.vL.temp.Calendar.EscapeCharsMap',
			'{$<
			@(vL.Set.RollingMonthsToDate.Modifier$(_suffixNoSpace)($1, $2))
			>}'
			);


			// Example usage:
			// Count($(Annual_vSetPreviousFULLMonthN(3)) orderNo)	// Count # orders in entire month 3 months prior
			Let vL.Set.Month.Modifier$(_suffixNoSpace) =
			MapSubString('_egbs.vL.temp.Calendar.EscapeCharsMap',
			'$(_egbs.vL.ClearFieldList)
			[$(_prefix)$(egbs.vL.Calendar.Field.YearMonthSerial)] = {@(=$(_egbs.vL.temp.vMaxModifier) [$(_prefix)$(egbs.vL.Calendar.Field.YearMonthSerial)]) + alt($1,0)  )}' 
			);

			Let vL.Set.Month$(_suffixNoSpace) =
			MapSubString('_egbs.vL.temp.Calendar.EscapeCharsMap',
			'{$<
			@(vL.Set.Month.Modifier$(_suffixNoSpace)($1))
			>}'
			);

			
		/* Quarter */
			Let vL.Set.Quarter.Modifier$(_suffixNoSpace) =
			MapSubString('_egbs.vL.temp.Calendar.EscapeCharsMap',
			'$(_egbs.vL.ClearFieldList)
			[$(_prefix)$(egbs.vL.Calendar.Field.QuarterSerial)] =  {@(=$(_egbs.vL.temp.vMaxModifier) [$(_prefix)$(egbs.vL.Calendar.Field.QuarterSerial)]) + alt($1,0) )}'
			);

			Let vL.Set.Quarter$(_suffixNoSpace) =
			MapSubString('_egbs.vL.temp.Calendar.EscapeCharsMap',
			'{$<
			@(vL.Set.Quarter.Modifier$(_suffixNoSpace)($1))
			>}'
			);				




		
		// Clean temp variables
		SET _egbs.vL.ClearFieldList =;
		SET _egbs.vL.temp.vMaxModifier =;
		// SET _egbs.vL.Calendar.SelectedFieldList_$(_suffixNoSpace) =;
		SET _egbs.vL.temp.v.Include.ExtSetVariables =;
		SET _suffixNoSpace=;

	ELSE //$(egbs.vL.Calendar.CreateSetVariables) = 0
		LET _suffixNoSpace =if(len('$(_prefix)')>0,
										if( (len('$(_prefix)') = index('$(_prefix)','.',-1)), //Sista tecknet är punkt
											'.' & replace(mid('$(_prefix)',1,len('$(_prefix)')-1),' ','_'), //Ta bort sista punkten
											'.' & replace('$(_prefix)',' ','_') 
									      ), 
										  replace('$(_prefix)',' ','_')
									);

		SET vL.Set.Quarter.Modifier$(_suffixNoSpace) =;
		SET vL.Set.Year.Modifier$(_suffixNoSpace) =;
		SET vL.Set.Month.Modifier$(_suffixNoSpace) =;
		SET vL.Set.YTD.Modifier$(_suffixNoSpace)=;
		SET vL.Set.RollingMonths.Modifier$(_suffixNoSpace) =;
		SET vL.Set.RollingMonthsToDate$(_suffixNoSpace) =;
		SET vL.Set.QTD.Modifier$(_suffixNoSpace) =;
		SET vL.Set.MTD.Modifier$(_suffixNoSpace) =;
		SET vL.Set.YTD.Modifier$(_suffixNoSpace) =;

		SET vL.Set.Quarter$(_suffixNoSpace) =;
		SET vL.Set.Year$(_suffixNoSpace) =;
		SET vL.Set.Month$(_suffixNoSpace) =;
		SET vL.Set.YTD$(_suffixNoSpace)=;
		SET vL.Set.RollingMonths$(_suffixNoSpace) =;
		SET vL.Set.QTD$(_suffixNoSpace) =;
		SET vL.Set.MTD$(_suffixNoSpace) =;
		SET vL.Set.YTD$(_suffixNoSpace) =;
		SET _suffixNoSpace=;

	ENDIF	// End of Generating Calendar Set Variables
ENDSUB
/* * End SUB egbs.Calendar * */

///$tab egbs.CalendarFromField
SUB egbs.CalendarFromField(_DateField, _DateTable, _KalenderPrefix)
/**
@version egbs-calendar.qvs
Skapa kalender från ett min och max-datum i ett fält. Anropar egbs.Calendar.
Se respektive sub för variabler och förklaring

@syntax CALL egbs.CalendarFromField(_DateField, _DateTable, _prefix)
@Syntax CALL egbs.CalendarFromField ('%ModDatum', '', 'Original')
@Param 1 Fält inehållande datum.
@Param 2 Valfri. Tabell/Qvd-fil som inehåller fältnamnet. Om inget anges används värden från alla RESIDENT-tabeller med fältnamnet. 
@Param 3 Valfri. Ett prefix som identifierer både kalendertabell och fältnamn.

@changelog 2018-07-30 Vegar Gör egbs-calendar.qvs oberende av andra filer i egbs-components.
*/
	CALL _egbs.calendar.GetMinMax('_vKalenderdag','$(_DateField)','$(_DateTable)')


	CALL egbs.Calendar( _vKalenderdag.Min, _vKalenderdag.Max,'$(_DateField)', _KalenderPrefix )
	LET  _vKalenderdag.Min =;
	LET  _vKalenderdag.Max =;
ENDSUB 
/* * End SUB egbs.CalendarFromField * */

SUB egbs.CalendarSetLanguage(_language)
/**
@version egbs-calendar.qvs
Skapar upp standardfältnamn för kalenderfält. Skriver över evt tidigare definierade variabelvärden.
@Param 1 Valfri Språkkod. SE, SWE ger Svenska. NB och NO ger Norska bokmål, NN och NNO ger Norska nynorsk. Om ingen eller felaktig språkkod används så ges engelska.
@syntax  CALL egbs.CalendarSetLanguage('SE')

@var egbs.vL.Calendar.Table.Name in rootnamn på kalendertabell.Om  variabel inte är definierad så sätts för språk för angett språkkod, eg 'SE'.
@var egbs.vL.Calendar.Field.Date in Namn på fält med dato.Om  variabel inte är definierad så sätts för språk för angett språkkod, eg 'SE'.
@var egbs.vL.Calendar.Field.Day in Namn på fält med dagnummer.Om  variabel inte är definierad så sätts för språk för angett språkkod, eg 'SE'.
@var egbs.vL.Calendar.Field.Week in Namn på fält med veckonummer.Om  variabel inte är definierad så sätts för språk för angett språkkod, eg 'SE'.
@var egbs.vL.Calendar.Field.Weekday in Namn på fält med veckodag Week.Om  variabel inte är definierad så sätts för språk för angett språkkod, eg 'SE'.
@var egbs.vL.Calendar.Field.YearWeek in Namn på fält med år-vecka Year-Week.Om  variabel inte är definierad så sätts för språk för angett språkkod, eg 'SE'.
@var egbs.vL.Calendar.Field.YearWeekSerial in Namn på fält med år-veckanummer Year-Week-Serial.Om  variabel inte är definierad så sätts för språk för angett språkkod, eg 'SE'.
@var egbs.vL.Calendar.Field.Month in Namn på fält med månad Month.Om  variabel inte är definierad så sätts för språk för angett språkkod, eg 'SE'.
@var egbs.vL.Calendar.Field.YearMonth in Namn på fält med år-månad Year-Month.Om  variabel inte är definierad så sätts för språk för angett språkkod, eg 'SE'.
@var egbs.vL.Calendar.Field.YearMonthSerial in Namn på fält med år-månadsnummer Year-Month-Serial.Om  variabel inte är definierad så sätts för språk för angett språkkod, eg 'SE'.
@var egbs.vL.Calendar.Field.Quarter in Namn på fält med kvartal Quarter.Om  variabel inte är definierad så sätts för språk för angett språkkod, eg 'SE'.
@var egbs.vL.Calendar.Field.Year in Namn på fält med år Year.Om  variabel inte är definierad så sätts för språk för angett språkkod, eg 'SE'.
@var egbs.vL.Calendar.Field.QuarterName in Namn på fält med kvartalnamn.Om  variabel inte är definierad så sätts för språk för angett språkkod, eg 'SE'.
@var egbs.vL.Calendar.Field.Tertial in Namn på fält med tertial.Om  variabel inte är definierad så sätts för språk för angett språkkod, eg 'SE'.
@var egbs.vL.Calendar.Field.TertialName in Namn på fält med tertialnamn.Om  variabel inte är definierad så sätts för språk för angett språkkod, eg 'SE'.

@changelog 2019-02-04 Vegar Kalenderfältnamnsvariablerna skrivs numera över även om de redan är definierade.
*/
	SWITCH UPPER('$(_language)')
		CASE 'SE','SWE'  //Svenska
			LET egbs.vL.Calendar.Table.Name='Kalender' ;
			LET egbs.vL.Calendar.Field.Date='Datum' ;
			LET egbs.vL.Calendar.Field.DateSerial='Datumlöpnummer' ;
			LET egbs.vL.Calendar.Field.Day='Dag';
			LET egbs.vL.Calendar.Field.Week='Veckonr';
			LET egbs.vL.Calendar.Field.Weekday='Veckodag';
			LET egbs.vL.Calendar.Field.YearWeek='Årvecka';
			LET egbs.vL.Calendar.Field.YearWeekSerial='Veckolöpnr';
			LET egbs.vL.Calendar.Field.Month='Månad';
			LET egbs.vL.Calendar.Field.YearMonth='Årmånad';
			LET egbs.vL.Calendar.Field.YearMonthSerial='Månadslöpnr';
			LET egbs.vL.Calendar.Field.Quarter='Kvartal';
			LET egbs.vL.Calendar.Field.Tertial='Tertial';
			LET egbs.vL.Calendar.Field.TertialName='Årterial';
			LET egbs.vL.Calendar.Field.Year='År';
			LET egbs.vL.Calendar.Field.QuarterName='Årkvartal';
			LET egbs.vL.Calendar.Field.QuarterSerial='Kvartalslöpnr';
		CASE 'NB','NOB','NO' //Norska bokmål
			LET egbs.vL.Calendar.Table.Name='Kalender' ;
			LET egbs.vL.Calendar.Field.Date='Dato' ;
			LET egbs.vL.Calendar.Field.DateSerial='Datoløpenummer' ;
			LET egbs.vL.Calendar.Field.Day='Dag';
			LET egbs.vL.Calendar.Field.Week='Ukenummer';
			LET egbs.vL.Calendar.Field.Weekday='Ukedag';
			LET egbs.vL.Calendar.Field.YearWeek='Åruke';
			LET egbs.vL.Calendar.Field.YearWeekSerial='Ukeløpenummer';
			LET egbs.vL.Calendar.Field.Month='Måned';
			LET egbs.vL.Calendar.Field.YearMonth='Årmåned';
			LET egbs.vL.Calendar.Field.YearMonthSerial='Månedsløpenummer';
			LET egbs.vL.Calendar.Field.Quarter='Kvartal';
			LET egbs.vL.Calendar.Field.Tertial='Tertial';
			LET egbs.vL.Calendar.Field.TertialName='Årterial';
			LET egbs.vL.Calendar.Field.Year='År';
			LET egbs.vL.Calendar.Field.QuarterName='Årkvartal';
			LET egbs.vL.Calendar.Field.QuarterSerial='Kvartalsløpenummer';
		CASE 'NNO','NN' //Norska nynorsk
			LET egbs.vL.Calendar.Table.Name='Kalender' ;
			LET egbs.vL.Calendar.Field.Date='Dato' ;
			LET egbs.vL.Calendar.Field.DateSerial='Datolaupenummer' ;
			LET egbs.vL.Calendar.Field.Day='Dag';
			LET egbs.vL.Calendar.Field.Week='Vekenummer';
			LET egbs.vL.Calendar.Field.Weekday='Vekedag';
			LET egbs.vL.Calendar.Field.YearWeek='Årveke';
			LET egbs.vL.Calendar.Field.YearWeekSerial='Vekelaupenummer';
			LET egbs.vL.Calendar.Field.Month='Månad';
			LET egbs.vL.Calendar.Field.YearMonth='Årmånad';
			LET egbs.vL.Calendar.Field.YearMonthSerial='Månadslaupenummer';
			LET egbs.vL.Calendar.Field.Quarter='Kvartal';
			LET egbs.vL.Calendar.Field.Tertial='Tertial';
			LET egbs.vL.Calendar.Field.TertialName='Årterial';
			LET egbs.vL.Calendar.Field.Year='År';
			LET egbs.vL.Calendar.Field.QuarterName='Årkvartal';
			LET egbs.vL.Calendar.Field.QuarterSerial='Kvartalslaupenummer';
		DEFAULT
			LET egbs.vL.Calendar.Table.Name= 'Calendar' ;
			LET egbs.vL.Calendar.Field.Date= 'Date' ;
			LET egbs.vL.Calendar.Field.DateSerial= 'Date Serial' ;
			LET egbs.vL.Calendar.Field.Day= 'Day';
			LET egbs.vL.Calendar.Field.Week= 'Week';
			LET egbs.vL.Calendar.Field.Weekday= 'Weekday';
			LET egbs.vL.Calendar.Field.YearWeek= 'Year Week';
			LET egbs.vL.Calendar.Field.YearWeekSerial= 'Year Week Serial';
			LET egbs.vL.Calendar.Field.Month= 'Month';
			LET egbs.vL.Calendar.Field.YearMonth= 'Year Month';
			LET egbs.vL.Calendar.Field.YearMonthSerial= 'Year Month Serial';
			LET egbs.vL.Calendar.Field.Quarter= 'Quarter';
			LET egbs.vL.Calendar.Field.Tertial= 'Tertial';
			LET egbs.vL.Calendar.Field.TertialName= 'Tertial Name';
			LET egbs.vL.Calendar.Field.Year= 'Year';
			LET egbs.vL.Calendar.Field.QuarterName= 'Quarter Name';
			LET egbs.vL.Calendar.Field.QuarterSerial= 'Quarter Serial';
	END SWITCH


ENDSUB


SUB egbs.CalendarLink(_FactTable, _Dates, _DateKey, _CalendarLinkID)
/**
@version egbs-Calendar.qvs
Skapar länkkalender med fälten, 
1 - [Fält som ska kopplas mot Fakta] 	- @Param 4
2 - [Typ av datum] 						- fälten som skickas in i @Param 2 ex ([Fält 1], [Fält 2], [Fält 3]
3 - [Länkfält till kalender] 			- @Param 3

@syntax CALL egbs.CalendarLink(_FactTable, _Dates, _DateKey, _RowId)
@Syntax CALL egbs.CalendarLink('Fact','[Date (Booking)], [Date (Start)]','%DateKey','TransactionID');
@Param 1 Tabell som innehåller fakta/transaktionsmängd, exempel "Fact"
@Param 2 Kommaseparerad lista med fält som skall tas från Fact/Transaction för att generera upp länkkalender. Dessa fälts namn blir "Type Of Date", exempel "Date1, Date2, Date3".
@Param 3 Fältnamn som skall kopplas mot kommande kalender - exempel, "%DateKey"
@Param 4 Fält som skall kopplas mot fakta/transaktionsmängd, exempel "TransactionID"
@var egbs.vL.Calendar.Table.Name in Basnamn på kalendertabellen. Om variabel inte är definierad så används ett defaultnamn på engelska.
@changelog 2019-01-28 Joachim NY FUNKTIONALITET egbs.CalendarLink


*/
	CALL _egbs.calendar.setEmptyVariable('egbs.vL.Calendar.Table.Name','Calendar' )


    [$(egbs.vL.Calendar.Table.Name)Link]:
    CROSSTABLE([$(egbs.vL.Calendar.Table.Name)], $(_DateKey), 1)
    LOAD DISTINCT
       $(_CalendarLinkID),
       $(_Dates)
    RESIDENT [$(_FactTable)]
    ;
ENDSUB



SUB egbs.CalendarCleanup
/**
	@version egbs-calendar.qvs
	Städar upp variabler efter egbs.calendar-scriptkörning

	@syntax CALL egbs.CalendarCleanup
	@VAR egbs.vL.Calendar.Field.DateKey ut Nollställer kalendervariablen.
	@VAR egbs.vL.Calendar.Field.Date ut Nollställer kalendervariablen.
	@VAR egbs.vL.Calendar.Field.Day ut Nollställer kalendervariablen.
	@VAR egbs.vL.Calendar.Field.Week ut Nollställer kalendervariablen.
	@VAR egbs.vL.Calendar.Field.Weekday ut Nollställer kalendervariablen.
	@VAR egbs.vL.Calendar.Field.YearWeek ut Nollställer kalendervariablen.
	@VAR egbs.vL.Calendar.Field.YearWeekSerial ut Nollställer kalendervariablen.
	@VAR egbs.vL.Calendar.Field.Month ut Nollställer kalendervariablen.
	@VAR egbs.vL.Calendar.Field.YearMonth ut Nollställer kalendervariablen.
	@VAR egbs.vL.Calendar.Field.YearMonthSerial ut Nollställer kalendervariablen.
	@VAR egbs.vL.Calendar.Field.Quarter ut Nollställer kalendervariablen.
	@VAR egbs.vL.Calendar.Field.Year ut Nollställer kalendervariablen.
	@VAR egbs.vL.Calendar.Field.QuarterName ut Nollställer kalendervariablen.
	@VAR egbs.vL.Calendar.WeekStartDay ut Nollställer kalendervariablen.
	@VAR egbs.vL.Calendar.BrokenWeeks ut Nollställer kalendervariablen.
	@VAR egbs.vL.Calendar.WeekOneReferenceDay ut Nollställer kalendervariablen.
	@changelog 2013-03-12 Vegar Utökade ränsning av variabler med egbs.v.Calendar.Table.Name
	@changelog 2015-03-31 Magnus Rensar fler kalenderfält
	@changelog 2018-07-30 Vegar BRYTER BAKÅTKOMPABILITET Flyttat sub från egbs-verktyg till egbs-calendar samt byta namn från egbs.Cleanup till egbs.CalendarCleanup
*/
	//Calendar
	LET egbs.vL.Calendar.Field.DateKey =;
	LET egbs.vL.Calendar.Field.DateSerial =;
	LET egbs.vL.Calendar.Table.Name =;
	LET egbs.vL.Calendar.Field.Date =;
	LET egbs.vL.Calendar.Field.Day =;
	LET egbs.vL.Calendar.Field.Week =;
	LET egbs.vL.Calendar.Field.Weekday =;
	LET egbs.vL.Calendar.Field.YearWeek =;
	LET egbs.vL.Calendar.Field.YearWeekSerial =;
	LET egbs.vL.Calendar.Field.Month =;
	LET egbs.vL.Calendar.Field.YearMonth = ;
	LET egbs.vL.Calendar.Field.YearMonthSerial =;
	LET egbs.vL.Calendar.Field.Quarter = ;
	LET egbs.vL.Calendar.Field.Year = ;
	LET egbs.vL.Calendar.Field.QuarterName =;
	LET egbs.vL.Calendar.Field.QuarterSerial =;
	LET egbs.vL.Calendar.YearWeek.Weekday =; //Issue #19
	LET egbs.vL.Calendar.WeekStartDay =;
	LET egbs.vL.Calendar.BrokenWeeks =;
	LET egbs.vL.Calendar.WeekOneReferenceDay =;
	LET egbs.vL.YearMonthFormat =;
	LET egbs.vL.Calendar.Field.Tertial = ;
	LET egbs.vL.Calendar.Field.TertialName =;
	LET egbs.vL.Calendar.CreateSetVariables =;

ENDSUB //egbs.CalendarCleanup

REM ===== avsluta egbs-components.qvs export =====;
REM ===== starta egbs-components.qvs export =====;

///$tab egbs.DropTables
SUB egbs.DropTables(_vL.DropFilter, _vL.KeepFilter)
	/**
	@version egbs.DropTables.qvs
	Loopar igenom och droppar alla tabeller i datamodellen exklusive egbs.*-tabeller. 
	@syntax CALL egbs.DropTables('Dim?') 
	@param 1 Valfri. _vL.DropFilter Filter pÃ¥ vilka tabeller som ska droppas. Wildchard ? och * kan anvÃ¤ndas. Eg: 'Dim?,Transaktioner' ELLER 'Dim1, Dim3'
	@param 2 Valfri. _vL.KeepFilter Filter pÃ¥ vilka tabeller som ska INTE ska droppas.  Wildchard ? och * kan anvÃ¤ndas. Eg: 'Dim2,Transaktioner' ELLER 'Dim?'
	@changelog 2014-05-28	Vegar Ãndrat sÃ¥ att Log-raden taggas upp med Level EGBS och inte EGBS-SUB. Logmeddelandet bÃ¶rjar med 'egbs.DropTables:'
	
	*/
	
	_egbs.vL.DropAllTables.keptTables = 0;
	_vL.DropFilter = IF(LEN(_vL.DropFilter)=0,chr(39)&'*'&chr(39),chr(39)&replace(_vL.DropFilter,',',chr(39)&','&chr(39))&chr(39));
	_vL.KeepFilter = _vL.KeepFilter & ',egbs.*'; //LÃ¤gger pÃ¥ filter fÃ¶r egbs.*-tabeller
	_vL.KeepFilter = IF(LEN(_vL.KeepFilter)=0,chr(39)&'*'&chr(39),chr(39)&replace(_vL.KeepFilter,',',chr(39)&','&chr(39))&chr(39));
	//Let _Filtren = _vL.DropFilter & ' || ' & _vL.KeepFilter;
	
	Do WHILE  _egbs.vL.DropAllTables.keptTables <  NoOfTables()
		//GÃ¤llande tabellnamn
		let _egbs.vL.DropAllTables.TableName = TableName('$(_egbs.vL.DropAllTables.keptTables)');
		//Filter
		if WildMatch(_egbs.vL.DropAllTables.TableName, $(_vL.DropFilter)) > 0 AND  WildMatch(_egbs.vL.DropAllTables.TableName, $(_vL.KeepFilter)) = 0 THEN
			drop table [$(_egbs.vL.DropAllTables.TableName)];
			Call egbs.Log('egbs.DropTables: $(_egbs.vL.DropAllTables.TableName) i SUB egbs.DropAllTables()', 'EGBS')
		else 
			LET _egbs.vL.DropAllTables.keptTables = _egbs.vL.DropAllTables.keptTables + 1;
		endif
	Loop 
	
	LET _egbs.vL.DropAllTables.keptTables =;
	LET _egbs.vL.DropAllTables.TableName =;
	LET _vL.KeepFilter=;
	LET _vL.DropFilter=;
END SUB

/* * End of sub StoreAllToQVD * */
///$tab End
REM ===== avsluta egbs-components.qvs export =====;
REM ===== starta egbs-components.qvs export =====;
///$tab egbs.LoadExpressions
SUB egbs.LoadExpressions(_fieldDataSource,_prefix)
/**
	@version  egbs-getexpression.qwv
	Laddar upp upp källfil med beräkningsuttryck och skapar de variabler som behövs för att leta av tabellen i grässnittet. Krav: Innehålla fält för följande information:
	  * UttrycksId
	  * Uttryck
	  * Rubrik
	  * Kommentar
	  * Formattyp
	  * Formateringsm?nster 
	  * Enhet
	  * Färg
	Namnsättningen av dessa fälten görs med hjäp av variablerna egbs.vL.loadExpression.field.*

	I dokumentet kan referenser till andra rader g?ras. Default ? <Ref>UttrycksId</Ref>


	Uppdateras ?en under partial load.
	 
	@syntax egbs.loadExpressions('$(vG.ImportPath)expressions.qvd','e.')
	@syntax egbs.loadExpressions('..\expressions.xlsx','e.')
	@param 1 Textstreng. S?kv? till fil som inehåller ber?nings uttryck. F?r excel-blad kr?s embedded lables och att uttrycken finns p?f?rsta fliken. Om filtyp ? skilld fr? qvd, xlsx, xls s?antast plain text.
	@param 2 Valfri textstreng. Ett prefix som läggs till alla fält i uttryckstabellen, kan jämföras med QUALIFY LOAD.

	@var egbs.vL.loadExpression.TableName in Streng. Tabellnamn för expresstabellen. Default ? 'egbs.expressions'.
	@var egbs.vL.loadExpression.field.Id in Streng. Fältnamn för uttrycksid i uttryckstabellen. Det ? ineh?let i detta f?tet som anv?ds i variabelanropen i applikationen.
	@var egbs.vL.loadExpression.field.Label in Streng. Fältnamn för uttryckets rubrik. Default ? Label.
	@var egbs.vL.loadExpression.field.Comment in Streng. Fältnamn för uttryckets kommentar. Default ? Comment.
	@var egbs.vL.loadExpression.field.Definition in Streng. Fältnamn för sj?va uttrycket. Default ? Definition.
	@var egbs.vL.loadExpression.field.Format in Streng. Fältnamn för uttryckets "datatyp", eg NUM eller DATE.
	@var egbs.vL.loadExpression.field.FormatPattern in Streng. Fältnamn för uttryckets formatering av "datatypen", eg. YYYY-MM-DD eller 0,0%. Default ? Format pattern.
	@var egbs.vL.loadExpression.field.Unit in Streng. Fältnamn för uttryckets enhet. Default ? Unit
	@var egbs.vL.loadExpression.field.Color in Streng. Fältnamn för uttryckets f?g. Default ? Color
	@var egbs.vL.loadExpression.field.Value in Streng. Fältnamn för uttrycket som ger v?det med korrekt uttryck och formatering. Default ? Value
	@var egbs.vL.loadExpression.expressionReferencePrefix in Streng. Prefix som definierar inledande tag som omslutar referenser till andra rader i uttrycksdokumentet.
	@var egbs.vL.loadExpression.expressionReferenceSuffix in Streng. Suffix som definierar avslutande tag som omslutar referenser till andra rader i uttrycksdokumentet.
	@var getLabelEvalueted out Uttryck. Uttryck som anv?ds för att h?ta det utv?derade v?det p?en uttrycksrubrik.
	@var getLabel out Uttryck. Uttryck som anv?ds för att h?ta det text-v?det p?en uttrycksrubrik.
	@var getColor out Uttryck. Uttryck som anv?ds för att h?ta det utv?derade v?det p?et f?guttryck i expressiontabellen.
	@var getValue out Uttryck. Uttryck som anv?ds för att h?ta det utv?derade v?det p?et v?det i expressiontabellen.
	@var getComment out Uttryck. Uttryck som anv?ds för att h?ta det  text-v?det p?et kommentaren i expressiontabellen.
	@var getCommentEvaluated out Uttryck. Uttryck som anv?ds för att h?ta det utv?derade v?det p?et kommentaren i expressiontabellen.
	@var getUnit out Uttryck. Uttryck som anv?ds för att h?ta det utv?derade v?det p?et kommentaren i expressiontabellen.
	@changelog 2013-07-09 Vegar	Skapat  egbs.LoadExpressions()
	@changelog 2013-07-11 Vegar #36 m?jligg?r partial reload p?getexpression
	@changelog 2013-10-21 Vegar	Möjlighet att referera till andra uttryck i excelblad.
	@changelog 2013-11-05 Vegar	Möjlighet att refera till motsvarande f?t för alla kolumner.
	@changelog 2014-03-11 Vegar #74 ?g?dat fel i hanteringen av intern-variabel i sub egbs.LoadExpressions som intr?far n? den ineh?ler '$('
	@changelog 2014-03-19 Vegar #77 Om Label ska hanteras som ett uttryck och inte rak text s?kan detta g?ras genom att anv?da variabeln getLabelEvaluated() i st?let för getLabel som endast hanterar text.
	@changelog 2014-03-19 Vegar #78 Lagt till output-variablerna i dokumentationen
	@changelog 2014-03-20 Vegar #79 Om kommentarer ska hanteras som ett uttryck och inte rak text s?kan detta g?ras genom att anv?da variabeln getCommentEvaluated() i st?let för getLabel som endast hanterar text.
	@changelog 2014-03-20 Vegar Förbättrat exempelflik. Uppdaterat excel med andra uttryck
	@changelog 2014-04-22 Vegar #83 QlikView 11.20 SR2 hanterade inte n? en intern sub-variabeln inneh?ll tecknet apostrof ('). Symptomen var att de generarade uttycken ineh?ll m?ga hashgenererade tecken. 
	@changelog 2018-07-30 Vegar Gjort egbs.getexpressions oberoende från andra qvs-filer i EGBS.Components. 
	@changelog 2018-07-30 Vegar Bytt ut _egbs.setEmptyVariable med _egbs.getExpressions.setEmptyVariable 

*/
	//Sätter defaultväden i fall variablerna ännu ej är satta.
	CALL _egbs.getExpressions.setEmptyVariable('egbs.vL.loadExpression.TableName',					'egbs.expressions' ) //Tabellnamn
	CALL _egbs.getExpressions.setEmptyVariable('egbs.vL.loadExpression.field.Id',					'Expression id' )	//Fältnamn för ExpressionId
	CALL _egbs.getExpressions.setEmptyVariable('egbs.vL.loadExpression.field.Label',				'Label' ) //Fältnamn för uttryckets rubrik
	CALL _egbs.getExpressions.setEmptyVariable('egbs.vL.loadExpression.field.Comment',				'Comment' ) //Fältnamn för uttryckets kommentar
	CALL _egbs.getExpressions.setEmptyVariable('egbs.vL.loadExpression.field.Definition',			'Definition' ) //Fältnamn för sj?va uttrycket
	CALL _egbs.getExpressions.setEmptyVariable('egbs.vL.loadExpression.field.Format',				'Format' ) //Fältnamn för uttryckets "datatyp", eg NUM eller DATE
	CALL _egbs.getExpressions.setEmptyVariable('egbs.vL.loadExpression.field.FormatPattern',		'Format pattern' ) //Fältnamn för uttryckets formatering av "datatypen", eg. YYYY-MM-DD eller 0,0%
	CALL _egbs.getExpressions.setEmptyVariable('egbs.vL.loadExpression.field.Unit',					'Unit' )	//Fältnamn för uttryckets enhet
	CALL _egbs.getExpressions.setEmptyVariable('egbs.vL.loadExpression.field.Color',				'Color' ) //Fältnamn för uttryckets f?g, eg. vL.corporateColor1, Red() eller RGB(120,120,120)
	CALL _egbs.getExpressions.setEmptyVariable('egbs.vL.loadExpression.field.Value',				'Value' ) 
	CALL _egbs.getExpressions.setEmptyVariable('egbs.vL.loadExpression.expressionReferencePrefix', '<ref>')
	CALL _egbs.getExpressions.setEmptyVariable('egbs.vL.loadExpression.expressionReferenceSuffix', '</ref>')

	/*
	 Kontrollerar vilket format filen är angivet i om inte qvd, xlsx,xls s?antas textfil.
	*/
		IF '.qvd' = lower(right('$(_fieldDataSource)', 4)) THEN
			SET _vL.Källa = ' $(_fieldDataSource) (qvd)';
		ELSEIF  '.xlsx' = lower(right('$(_fieldDataSource)', 5)) THEN
			SET _vL.Källa = ' $(_fieldDataSource) (ooxml, embedded labels)';	
		ELSEIF  '.xls' = lower(right('$(_fieldDataSource)', 4)) THEN
			SET _vL.Källa = ' $(_fieldDataSource) (biff, embedded labels)';
		ELSE 
			SET _vL.Källa = ' $(_fieldDataSource)';	// Antar textfil
		ENDIF

	/* Randomtecken som s?erst?ler att concateneringen inte plockar upp v?den som faktisk anv?ds i uttrycken */
		Let _expressionDelimiter = PurgeChar(Hash256(rand()), '$' & chr(39)); // //Ref #74 @0:5 QV9 hanterar inte $ i variabel  //#83 QV 11.00 Hanterar inte ' i variabel
		Let _expressionDollar = PurgeChar(Hash256(rand()), '$' & chr(39);  //Ref #74 @0:5 QV9 hanterar inte $ i variabel //#83 QV 11.00 Hanterar inte ' i variabel

	/* 
	* H?tar uttryck fr? k?lfil till en temptabell _tmp_expressions 
	*/
		_tmp_expressions:
		REPLACE LOAD 
			[$(egbs.vL.loadExpression.field.Id)] as _fieldId,
			[$(egbs.vL.loadExpression.field.Id)] & '|$(_expressionDelimiter)|' & 	
			Replace([$(egbs.vL.loadExpression.field.Label)],'$','|$(_expressionDollar)|')& '|$(_expressionDelimiter)|' & 
			Replace([$(egbs.vL.loadExpression.field.Comment)],'$','|$(_expressionDollar)|')& '|$(_expressionDelimiter)|' & 
			Replace([$(egbs.vL.loadExpression.field.Definition)],'$','|$(_expressionDollar)|')  & '|$(_expressionDelimiter)|' & 
			[$(egbs.vL.loadExpression.field.Format)] & '|$(_expressionDelimiter)|' & 
			Replace([$(egbs.vL.loadExpression.field.Color)], '$', '|$(_expressionDollar)|') & '|$(_expressionDelimiter)|'  & 
			[$(egbs.vL.loadExpression.field.FormatPattern)] & '|$(_expressionDelimiter)|' &  [$(egbs.vL.loadExpression.field.Unit)] as _fieldValues
		FROM
		$(_vL.Källa)
		WHERE len([$(egbs.vL.loadExpression.field.Id)])>0
		;
		let _vL.Källa=;

		when IsPartialReload()=-1 Drop table [$(egbs.vL.loadExpression.TableName)];

	SUB _egbs.getExpressions.createDefinition(strIN, _subfieldNo)
	/*
	H?tar uttryck fr? annan rad om den refererar till annat uttryck
	*/
		IF SubStringCount('$(strIN)', '$(egbs.vL.loadExpression.expressionReferencePrefix)') > 0 THEN
			LET vL.tmpExpr = '$(egbs.vL.loadExpression.expressionReferencePrefix)'& TextBetween('$(strIN)','$(egbs.vL.loadExpression.expressionReferencePrefix)','$(egbs.vL.loadExpression.expressionReferenceSuffix)')&'$(egbs.vL.loadExpression.expressionReferenceSuffix)'; //H?tar ut det referade uttrycket som det st? i k?ldokumentet			
			LET vL.tmpExprID = TextBetween('$(strIN)','$(egbs.vL.loadExpression.expressionReferencePrefix)','$(egbs.vL.loadExpression.expressionReferenceSuffix)') ;  //H?tar uttrycksnamnet dvs utan prefix/suffix som anv?ds för att definiera referenser
			LET vL.NewExpr = SubField(Lookup('_fieldValues', '_fieldId', '$(vL.tmpExprID)', '_tmp_expressions'), '|$(_expressionDelimiter)|', $(_subfieldNo)); //H?tar uttrycket som g?ler för det refereade uttrycket	
			call _egbs.getExpressions.createDefinition(replace('$(strIN)', '$(vL.tmpExpr)', '$(vL.NewExpr)'),'$(_subfieldNo)');		
		ELSE
			LET _$(_vL.fältnamn) = '$(strIN)';
			LET vL.tmpExpr=;
			LET vL.tmpExprID =;
			LET vL.NewExpr = ;		
		ENDIF
		
	ENDSUB //_egbs.getExpressions.createDefinition

	//Byter ut referens mot referensens v?de.
	for _tmp_expressionsRad = 1 to NoOfRows('_tmp_expressions')  //F?r varje uttrycksrad

		LET _ExpressionID = SubField(FieldValue('_fieldValues', $(_tmp_expressionsRad)), '|$(_expressionDelimiter)|', 1);	 //H?tar uttrycksid
		//H?tar uttryck fr? ?vriga f?t genom en loop. D? _egbs.getExpressions.createDefinition anropas rekursivt för att h?ta fram referenser i uttrycken.
		for each _vL.fältnamn in 'Label', 'Comment', 'Definition','Format','Color','FormatPattern','Unit' 
			let _vL.fältnamnNo = Match('$(_vL.fältnamn)','ID','Label', 'Comment', 'Definition','Format','Color','FormatPattern','Unit'); //Ger 2, 3, 4, 5, 6, 7, 8
			IF SubStringCount( SubField(FieldValue('_fieldValues', $(_tmp_expressionsRad)), '|$(_expressionDelimiter)|', $(_vL.fältnamnNo)), '$(egbs.vL.loadExpression.expressionReferencePrefix)') > 0 THEN
				call _egbs.getExpressions.createDefinition(SubField(FieldValue('_fieldValues', '$(_tmp_expressionsRad)'), '|$(_expressionDelimiter)|', $(_vL.fältnamnNo)),'$(_vL.fältnamnNo)')	
			ELSE
				
				LET _$(_vL.fältnamn) = SubField(FieldValue('_fieldValues', $(_tmp_expressionsRad)), '|$(_expressionDelimiter)|', $(_vL.fältnamnNo));
				
			ENDIF
			
			let _vL.fältnamnNo =;
		next _vL.fältnamn

		let _vL.fältnamn =;


		/*
		Laddar tabellen som kommer finnas i datamodellen.
		*/
		[$(egbs.vL.loadExpression.TableName)]:
		ADD	load
			'$(_ExpressionID)' as [$(_prefix)$(egbs.vL.loadExpression.field.Id)],
			Replace('$(_Label)','|$(_expressionDollar)|', '$')  as [$(_prefix)$(egbs.vL.loadExpression.field.Label)],		
			Replace('$(_Comment)','|$(_expressionDollar)|', '$') as [$(_prefix)$(egbs.vL.loadExpression.field.Comment)],
			Replace('$(_Definition)','|$(_expressionDollar)|', '$') as [$(_prefix)$(egbs.vL.loadExpression.field.Definition)],
			Replace('$(_Format)','|$(_expressionDollar)|', '$') as [$(_prefix)$(egbs.vL.loadExpression.field.Format)],
			Replace('$(_Color)','|$(_expressionDollar)|', '$') as [$(_prefix)$(egbs.vL.loadExpression.field.Color)],
			Replace('$(_FormatPattern)','|$(_expressionDollar)|', '$') as [$(_prefix)$(egbs.vL.loadExpression.field.FormatPattern)],
			Replace('$(_Unit)','|$(_expressionDollar)|', '$') as [$(_prefix)$(egbs.vL.loadExpression.field.Unit)],
			IF(	LEN('$(_Format)') > 0,
				Replace('$(_Format)','|$(_expressionDollar)|', '$') & '(' & 	Replace('$(_Definition)','|$(_expressionDollar)|', '$')  &   ', ' & CHR(39) & 
				Replace('$(_FormatPattern)','|$(_expressionDollar)|', '$')  & CHR(39) & ')' ,
				Replace('$(_Definition)','|$(_expressionDollar)|', '$') )	AS [$(_prefix)$(egbs.vL.loadExpression.field.Value)]
			autoGenerate 1;
		
	next _tmp_expressionsRad
	Let _tmp_expressionsRad =;
	Let _ExpressionID=;
	for each _vL.fältnamn in 'Label', 'Comment', 'Definition','Format','Color','FormatPattern','Unit'
		LET _$(_vL.fältnamn)=;
	next _vL.fältnamn
	LET _vL.fältnamn=;

	DROP TABLE
	_tmp_expressions;


	//	Skapar variablerna som anv?ds i applikationen
		LET getLabel = 'MaxString({<[$(_prefix)$(egbs.vL.loadExpression.field.Id)]={'&chr(39)&chr(36)&1&chr(39)&'}>} [$(_prefix)$(egbs.vL.loadExpression.field.Label)])';
		LET getColor = '$'&'(=only({<[$(_prefix)$(egbs.vL.loadExpression.field.Id)]={'&chr(39)&chr(36)&1&chr(39)&'}>} [$(_prefix)$(egbs.vL.loadExpression.field.Color)]))';
		LET getValue = '$'&'(=only({<[$(_prefix)$(egbs.vL.loadExpression.field.Id)]={'&chr(39)&chr(36)&1&chr(39)&'}>} [$(_prefix)$(egbs.vL.loadExpression.field.Value)]))';  
		LET getComment = 'MaxString({<[$(_prefix)$(egbs.vL.loadExpression.field.Id)]={'&chr(39)&chr(36)&1&chr(39)&'}>} [$(_prefix)$(egbs.vL.loadExpression.field.Comment)])';
		LET getCommentEvaluated = '$'&'(=MaxString({<[$(_prefix)$(egbs.vL.loadExpression.field.Id)]={'&chr(39)&chr(36)&1&chr(39)&'}>} [$(_prefix)$(egbs.vL.loadExpression.field.Comment)])';
		LET getUnit = 'MaxString({<[$(_prefix)$(egbs.vL.loadExpression.field.Id)]={'&chr(39)&chr(36)&1&chr(39)&'}>} [$(_prefix)$(egbs.vL.loadExpression.field.Unit)])';
		LET getLabelEvaluated = '$'&'(=MaxString({<[$(_prefix)$(egbs.vL.loadExpression.field.Id)]={'&chr(39)&chr(36)&1&chr(39)&'}>} [$(_prefix)$(egbs.vL.loadExpression.field.Label)]))';

		LET _expressionDelimiter =;
		LET _expressionDollar =;

ENDSUB

SUB _egbs.getExpressions.setEmptyVariable(_var, _default)
	/**
	@version egbs-expressions.qwv
	Sätter defaultvärde på variabel så länge den inte är förhandsdefinierad i scriptet t.ex via språk/anpassnings-includes.
	@syntax CALL _egbs.getExpressions.setEmptyVariable('Var1', 'Defaultvärde 1')
	@param 1 Textstreng. Namn på variabel som ska sättas värde på. 
	@param 2 Textstreng. Defaultvärdet på variabeln.
	@var <Parameter 1> ut Returnerar variabeln deklarerad som paramteter 1 med befintligt eller defaultvärde

	*/
	LET $(_var) = if(len($(_var))=0, _default, $(_var));
ENDSUB


sub egbs.GetExpressionsCleanup
/**
	@version egbs-calendar.qvs
	Städar upp variabler efter egbs.GetExpressions-scriptkörning
	
	@VAR egbs.vL.loadExpression.TableName ut Nollställer variabeln.
	@VAR egbs.vL.loadExpression.field.Id ut Nollställer variabeln.
	@VAR egbs.vL.loadExpression.field.Label ut Nollställer variabeln.
	@VAR egbs.vL.loadExpression.field.Comment ut Nollställer variabeln.
	@VAR egbs.vL.loadExpression.field.Definition ut Nollställer variabeln.
	@VAR egbs.vL.loadExpression.field.Format ut Nollställer variabeln.
	@VAR egbs.vL.loadExpression.field.FormatPattern ut Nollställer variabeln.
	@VAR egbs.vL.loadExpression.field.Unit ut Nollställer variabeln.
	@VAR egbs.vL.loadExpression.field.Color ut Nollställer variabeln.
	@VAR egbs.vL.loadExpression.field.Value ut Nollställer variabeln.

	@changelog 2013-07-08 Vegar La till variabelborttag från nya expression-funktionen
	@changelog 2018-07-30 Vegar BRYTER BAKÅTKOMPABILITET Flyttat sub från egbs-verktyg till egbs-getexpressions samt bytt namn från egbs.Cleanup till egbs.getExpressionsCleanup
	@changelog 2018-07-30 Vegar Hanterar nollning av egbs.vL.loadExpression.expressionReferencePrefix och egbs.vL.loadExpression.expressionReferenceSuffix.

*/
	//Expressions
	SET egbs.vL.loadExpression.TableName=;
	SET egbs.vL.loadExpression.field.Id=;
	SET egbs.vL.loadExpression.field.Label=;
	SET egbs.vL.loadExpression.field.Comment=;
	SET egbs.vL.loadExpression.field.Definition=;
	SET egbs.vL.loadExpression.field.Format=;
	SET egbs.vL.loadExpression.field.FormatPattern=;
	SET egbs.vL.loadExpression.field.Unit=;
	SET egbs.vL.loadExpression.field.Color=;
	SET egbs.vL.loadExpression.field.Value=;
	SET egbs.vL.loadExpression.expressionReferencePrefix=;
	SET egbs.vL.loadExpression.expressionReferenceSuffix=;	

ENDSUB // egbs.GetExpressionsCleanup
///$tab Avsluta export till egbs.qvs
REM ===== avsluta egbs-components.qvs export =====;
///$tab egbs.GetMinMax
SUB egbs.GetMinMax (_returvariabel, _falt, _kalltabell)
/**
@version  egbs-getminmax.qvs
Hamtar min och max-varden fraan tabell, qvd eller textfil.

@syntax CALL egbs.GetMinMax('vStats', 'LastUpdate', ['Transactions.qvd']);

@param 1 String. Stomnamn paa variabler som ska returneras.  Variablerna Stomnamn.Max och  Stomnamn.Min kommer bli skapad.
@param 2 String. Faltnamn
@param 3 String, Valfri. Kalla som inehÃ¥ller faltet. Om kalltabellen ar en qvd-fil lases den, annars antas att kallan ar en RESIDENT tabell. Om parametern ar utesluten, anvands varden pÃ¥ frÃ¥n alla fÃ¶rekomster av faltet.

@var *.Min ut Minsta vardet i faltet
@var *.Min ut Hogsta vardet i faltet

@changelog 2016-11-14 Vegar andrar till snabbare metod som loopar paa faltvarden
@changelog 2016-11-15 Vegar Ändrar ä, ö och å i scriptkoden mer internationella tecken som kan lasas i med flere encodings
@changelog 2018-07-27 Vegar Tar bort beroenden till andra egbs-components qvs-filer.
@changelog 2018-07-27 Vegar Fix kring att anrop mot specifika qvd eller resident-tabeller lämnar kvar en en-kolumnstabell
*/

	LET _prefix = ;
	IF QvdCreateTime('$(_kalltabell)') THEN //QVD-fil	

		LET _prefix = '_egbs.'&QvdTableName('$(_kalltabell)')&'.';
		
		_egbstemp.temptab:
		LOAD 
			[$(_falt)] as [$(_prefix)$(_falt)]
		FROM 
			[$(_kalltabell)] (qvd)
		;
		let vL.DropNewFieldWhenFinished = true();	
	ELSEIF	NoOfRows('$(_kalltabell)') > 0 then  //om resuident specifik tabell
		LET _prefix = '_egbs.$(_kalltabell).';
		
		_egbstemp.temptab:
		LOAD 
			[$(_falt)] as [$(_prefix)$(_falt)]
		Resident 
			[$(_kalltabell)]
		;
		let vL.DropNewFieldWhenFinished = true();
	ELSEIF len('$(_kalltabell)') > 0 THEN //Kalltabell angivet, men fÃ¥r inte traff ovan.
	 	TRACE ## WARNING: egbs.getminmax('$(_returvariabel)', '$(_falt)', '$(_kalltabell)');
	 	TRACE             '$(_kalltabell)' ar ingen giltig tabell eller qvd-fil. Hämtar min/max från alla fältvärden.;
	ENDIF  
	MinMax:
		Load
			Min([$(_prefix)$(_falt)]) as  _egbstemp.minval,
			Max([$(_prefix)$(_falt)]) as _egbstemp.maxval
		;
		Load
			FieldValue( '$(_prefix)$(_falt)', IterNo()) as [$(_prefix)$(_falt)]
		Autogenerate(1)
		While 
			NOT IsNull(FieldValue('$(_prefix)$(_falt)', IterNo()))
		;
	LET $(_returvariabel).Max = replace(peek('_egbstemp.maxval'), ',', '.');
	LET $(_returvariabel).Min = replace(peek('_egbstemp.minval'), ',', '.');
	Drop table MinMax;
	WHEN vL.DropNewFieldWhenFinished DROP FIELD [$(_prefix)$(_falt)];
	LET vL.DropNewFieldWhenFinished=;
	LET _prefix=;
ENDSUB///$tab egbs.Icons
SUB egbs.Icons (_iconsPath)
REM ===== starta egbs-components.qvs export =====;

/**
@version egbs-icons.qwv $Revision$  $Author$
Laddar alla bilder (.png, .jpg, .bmp och .gif)  i ett angiven mapp i qlikview-filen fÃ¶r att kunna anvÃ¤ndas frontend.

@syntax CALL  egbs.Icons ('c:\Icons\')
@param 1 _iconsPath Streng med sÃ¶kvÃ¤g till mapp som innehÃ¥ller bildfiler (filtrerar pÃ¥ png, jpg, bmp och gif). BÃ¥de absolutta och relativa sÃ¶kvÃ¤gar accepteras.
@changelog 2013-03-11 Vegar Skapat egbs.Icons
@changelog 2013-06-18 Vegar #23 Tog bort mÃ¶jligheten att skicka med en variabel som droppar icon-tabellen. Om icon-tabellen droppas sÃ¥ fÃ¶rsvinner Ã¤ven de bundlade ikonerna. 
@changelog 2014-03-11 Vegar #73 Tog bort Parameter nr 2 _keepIconTable. Funktionaliteten togs bort i version 1.5.  AnvÃ¤ndes tidigare fÃ¶r att ange om tabellen [egbs.Icons] skulle droppas eller inte. Det visade sig att Ã¤ven iconerna droppades om tabellen fÃ¶rsvann. Om variablen rekomenderas att tas bort frÃ¥n befintliga anrop.
*/
	// Loop through the supported image file types 
	FOR Each egbs.Icons.v.Extension IN 'png', 'jpg', 'bmp', 'gif'
		
		// Loop through all the image files in the passed path
		FOR EACH egbs.Icons.v.Image IN filelist (_iconsPath & '*.' & egbs.Icons.v.Extension);
		
			// Get the file name without the file extension
			LET egbs.Icons.v.CurrImageName = capitalize(subfield(subfield(egbs.Icons.v.Image, '\', -1), '.', 1));

				// Build the list of icons and then bundle the image in to the application
				egbs.Icons:
				LOAD
					trim('$(egbs.Icons.v.CurrImageName)') AS egbs.Icons
				AUTOGENERATE 1;
			BUNDLE Info LOAD
				trim('$(egbs.Icons.v.CurrImageName)') AS egbs.Icons,
				'$(egbs.Icons.v.Image)'
			AUTOGENERATE 1;
				     
		NEXT egbs.Icons.v.Image;
	NEXT egbs.Icons.v.Extension;
	
	// Clear all variables so they don't appear in the frontend
	LET _iconsPath = null();
	LET egbs.Icons.v.Extension = null();
	LET egbs.Icons.v.Image = null();
	LET egbs.Icons.v.CurrImageName = null();
	
END SUB



/* * End of sub Icons * */
REM ===== avsluta egbs-components.qvs export =====; 
///$tab Ändringslogg
REM ===== starta egbs-components.qvs export =====;
///$tab list-files
SUB egbs.ListFiles (dir, _filter, _underkataloger, callback)
/**
@version egbs-listfiles.qvs
Skapa lista med filer från en mapp med eller utan filer i undermappar.

Om Subanrop används så kommer sub köras för värje fil som listas.
@param 1 Textstreng. Mapp. Absolut eller relativ sökväg. (Absolut sökväg rekomenderas)
@param 2 Textstreng, Valfri. Filter för att begränsa filurvalet. Exempelvis, '*.qvd'. Standardvärdet är '*'.
@param 3 Sant/Falskt, Valfri. Om sant (-1) så scan underkataloger. Om falskt (0) så scan inte undermappar. Standardvärde är sant.
@param 4 Textsträng, Valfri. Namn på subrutin som ska anropas för värje fil. 

@syntax CALL egbs.ListFiles('c:\Din\mapp\', ['*.qvd'], ['-1'], ['callbackSub']); 
@changelog 2013-04-15 Vegar #18 Funktion egbs.ListFiles skapat
@changelog 2018-07-30 Vegar Tagit bort beroenden till övriga filer i egbs-components
*/
LET _filter = if(len('$(_filter)')=0, '*', '$(_filter)');
CALL _egbs.ListFiles.setEmptyVariable('_underkataloger','-1' )

LET _doCallback = if(len('$(callback)')>0,-1,0);	// -1 om callback ska göras

// Load info about each file in the directory
FOR EACH _fil in filelist('$(dir)' &  '\' & '$(_filter)');
	IF $(_doCallback) THEN
		CALL $(callback) ('$(_fil)');
	ELSE
		egbs.ListFiles:
		LOAD 
			'$(_fil)' as [egbs.Listed File Path]
		AutoGenerate 1
		;
	ENDIF
NEXT _fil;
// Alla filer i katalogen är listade
// Processer alla  _underkataloger till $(dir) rekursivt
IF '$(_underkataloger)' THEN
	FOR EACH _underkat in dirlist( '$(dir)' & '\*' )
		CALL egbs.ListFiles('$(_underkat)', '$(_filter)', '$(_underkataloger)', '$(callback)')
	NEXT _underkat;
ENDIF	

SET _doCallback=;
SET _fil=;
SET _underkat=;
	
END SUB


SUB _egbs.ListFiles.setEmptyVariable(_var, _default)
	/**
	@version egbs-expressions.qwv
	Sätter defaultvärde på variabel så länge den inte är förhandsdefinierad i scriptet t.ex via språk/anpassnings-includes.
	@syntax CALL _egbs.getExpressions.setEmptyVariable('Var1', 'Defaultvärde 1')
	@param 1 Textstreng. Namn på variabel som ska sättas värde på. 
	@param 2 Textstreng. Defaultvärdet på variabeln.
	@var <Parameter 1> ut Returnerar variabeln deklarerad som paramteter 1 med befintligt eller defaultvärde

	@changelog 2018-07-30 Vegar Lagt till SUB som ersätter _egbs.setEmptyVariable som fanns i ett annat egbs-components qvs-fil.
	*/
	LET $(_var) = if(len($(_var))=0, _default, $(_var));
ENDSUB
///$tab avsluta egbs-components.qvs export
REM ===== avsluta egbs-components.qvs export =====;
///$tab egbs-listvalues 
REM
2013-06-13	Vegar Lie Arntsen
			#22 Ãndrat metadatabeskrivningen som dyker upp i dokumentationen. Den var felformaterat sÃ¥ att det sÃ¥g knasigt ut.
2013-03-30	Joachim Boivie Skapat funktionen
2013-03-30	Vegar Lie Arntsen Fixat bugg #9 "Fel vÃ¤rden kan visas i egbs.GetListValues". 
			Lagt till mer flexibel anvÃ¤nding  som gÃ¶r tabellnamn valfritt.  
			Lagt till valfri parameter om distinkta vÃ¤rden ska anges eller inte.
;
REM ===== starta egbs-components.qvs export =====;
///$tab GetListValues
SUB egbs.GetListValues(_egbs.variabelList, _egbs.fieldName, _egbs.tableName, _distinct)
/**
@version egbs.GetListValues.qvs
@created 2013-03-20
HÃ¤mtar vÃ¤rden frÃ¥n en tabell och en kolumn och konkatenerar dessa vÃ¤rden till en kommaseparerad lista med chr(39) runt varje vÃ¤rde. Sparar listan i angiven variabel.

@syntax CALL egbs.GetListValues ('vL.dinVariabel', 'Kolumn', ['Tabell'], [-1])
@param 1 Text, Variabel that will hold the result of the operation.
@param 2 Text, Column/Field that holds the data that will end up as a list.
@param 3 Optional. Text, Table that holds the column.
@param 4 Optional. true/false. -1 if you want to use distinct values.
@var Param1 ut En kommaseparerad lista med chr(39)/apostrof runt vÃ¤rje vÃ¤rde.
*/
IF  len('$(_egbs.tableName)')=0 then
	SET _egbs.datamÃ¤ngd =  ";  Load FieldValue('$(_egbs.fieldName)',RecNo()) as $(_egbs.fieldName)  AutoGenerate  FieldValueCount('$(_egbs.fieldName)')";
ELSE
	LET _distinct = IF('$(_distinct)'= -1,'DISTINCT','');
	SET _egbs.datamÃ¤ngd = Resident $(_egbs.tableName);
ENDIF
	
_egbs.getlistvalues: 
NOCONCATENATE LOAD 
	chr(39) & concat($(_distinct) $(_egbs.fieldName), chr(39)&','&chr(39))& chr(39) as _egbs.getlistvalues  
	$(_egbs.datamÃ¤ngd)
;
LET $(_egbs.variabelList) =peek('_egbs.getlistvalues');

Drop table _egbs.getlistvalues;
set _egbs.datamÃ¤ngd=;

ENDSUB
///$tab Avslutar exportdel
REM ===== avsluta egbs-components.qvs export =====;
///$tab egbs-store
REM ===== starta egbs-components.qvs export =====;
///$tab egbs.StoreQvd
SUB egbs.StoreQvd(_table, _output, _dropTable)
/**
@version egbs-store.qwv $Revision$  $Author$ 
Store-procedyr for QVD-filer
Sparar undan angiven Tabell till angiven mapp eller fil. Möjligt att droppa tabell efter att filen är sparad.
Spar ned metadata om filen till tabell egbs.ListOutputFiles
@syntax CALL egbs.StoreQvd(_table, [_output], [_dropTable])
@syntax CALL egbs.StoreQvd('Trans', '$(vG.QVDPath)Transaktioner.qvd', '-1')
@param 1 Tabellnamn i datamodellen
@param 2 Sökväg där qvd blir sparad. Antar att sökväg som slutar med ".qvd" är filnamn och annars är mapp angiven och qvd-filen får sammma namn som tabellen
@param 3 Valfri - Ange '-1' om tabellen ska droppas efter den har sparats.
@changelog 2013-03-13 Vegar Ändrat hur input för StoreQvd och StoreTxt hanteras. Man kan nu ange sökväg i form av mapp eller sökväg med filnamn.
@changelog 2013-04-24 Magnus Lagt till fullständigt filnamn i outputtabellen.
@changelog 2013-04-24 Vegar Lagt till EGBS-SUB-loggingtransaktioner i flödet. 
@changelog 2015-05-20 Magnus Justerat logiken för att hantera dubbla backslash i sökvägen
@changelog 2018-07-27 Vegar Tar bort beroenden till andra egbs-components qvs-filer genom att byta från egbs.log till TRACE;
@changelog 2022-01-20 Magnus Hantera LIB och / i sökvägar som används i Qlik Sense.
*/
	IF UPPER(Left('$(_output)',3)) = 'LIB' THEN
		SET _separator = '/';
		LET _output = Replace('$(_output)','\','/');
	ELSE
		SET _separator = '\';
		LET _output = Replace('$(_output)','/','\');
	ENDIF

	IF '$(_output)' = '' THEN 
		SET _output = '.$(_separator)$(_table).qvd';
	ELSEIF RIGHT('$(_output)',1) = '$(_separator)' THEN
		SET _output = '$(_output)$(_table).qvd';
	ELSEIF RIGHT(UPPER(_output),4) <> '.QVD' THEN
		SET _output = '$(_output)$(_separator)$(_table).qvd';
	ENDIF

	// Spara filen
	Store [$(_table)] into [$(_output)] (qvd);
	// Fyller outputtabelll med metadata om den sparade qvd-filen.
	CALL _egbs.ListOutputFile('$(_table)', '$(_output)', '(qvd)')

	// Ta eventuellt bort filen
	If '$(_dropTable)' = '-1' then
		drop table [$(_table)];
	ENDIF
	// Logga sparandet i egbs log
	//call egbs.Log('egbs.StoreQvd: Saved table $(_table) to qvd-file.','EGBS-SUB')
	TRACE # egbs-components: Saved table $(_table) to $(_output).;
	// Clear variables before end of function
	SET _output=;
	SET _table=;
	SET _dropTable=;
	SET _separator =;
ENDSUB
/* * End SUB egbs.StoreQvd * */


///$tab egbs.StoreTxt
SUB egbs.StoreTxt(_table, _output, _dropTable, _delimiter)
/**
@version egbs-sparafiler.qwv $Revision$  $Author$ 
DEPRECIATED 
Store-procedyr for TXT-filer
Spar ned och evt. droppar tabell till txt-fil.
Spar ned metadata om filen till tabell egbs.ListOutputFiles
@syntax CALL egbs.StoreTxt(Tabell, [Output], [_dropTable], [_delimiter])
@syntax CALL egbs.StoreTxt('Transaktioner', '$(vG.QVDPath)', [_dropTable], [_delimiter])
@syntax CALL egbs.StoreTxt('Transaktioner', '$(vG.QVDPath)Mina.Transaktioner.csv', -1, [_delimiter])
@syntax CALL egbs.StoreTxt('Transaktioner', '$(vG.QVDPath)Mina.Transaktioner.txt', -1, '\t')
@param 1 Tabellnamn i datamodellen
@param 2 Sökväg där qvd blir sparad
@param 3 Valfri - Ange -1 om tabellen ska droppas efter Store.
@param 4 Valfri - Fältseparator. Defaultvärde är ';'. Ange '\t' för tabb-separerad.
@changelog 2013-03-13 Vegar Ändrat hur input för StoreQvd och StoreTxt hanteras. Man kan nu ange sökväg i form av mapp eller sökväg med filnamn.
@changelog 2013-04-24 Magnus Lagt till fullständigt filnamn i outputtabellen.
@changelog 2013-04-24 Vegar Lagt till EGBS-SUB-loggingtransaktioner i flödet. 
@changelog 2015-05-20 Magnus Justerat logiken för att hantera dubbla backslash i sökvägen, samt lagt till parametern _delimiter
@changelog 2018-07-27 Vegar Specifierat codepage = utf8 och att filen har embeddel labels. 
@changelog 2018-07-27 Vegar Tar bort beroenden till andra egbs-components qvs-filer genom att byta från egbs.log till TRACE;
*/
	IF '$(_output)' = '' THEN 
		SET _output = '.\$(_table).txt';
	ELSEIF RIGHT('$(_output)',1) = '\' THEN
		SET _output = '$(_output)$(_table).txt';
	ELSEIF RIGHT(UPPER(_output),4) <> '.TXT' THEN
		SET _output = '$(_output)\$(_table).txt';
	ENDIF

	// Sätt default delimiter if not set
	IF '$(_delimiter)' = '' THEN
		SET _delimiter = ';';
	ENDIF
	// Spara filen
	Store [$(_table)] into [$(_output)] (txt, utf8, embedded labels, delimiter is '$(_delimiter)');
	// Fyller outputtabelll med metadata om den sparade txt-filen.
	CALL _egbs.ListOutputFile( '$(_table)', '$(_output)', "(txt, utf8, embedded labels, delimiter is '$(_delimiter)', msq)" )

	// Ta eventuellt bort filen
	If '$(_dropTable)' = '-1' then
		drop table [$(_table)];
	ENDIF
	// Logga sparandet i egbs log
	TRACE # egbs-components: Saved table $(_table) to $(_output).;
	// Clear variables before end of function
	SET _output=;
	SET _table=;
	SET _dropTable=;
	SET _delimiter=;

ENDSUB
/* * End SUB egbs.StoreTxt * */
///$tab egbs.StoreCsv
SUB egbs.StoreCsv(_table, _output, _dropTable, _delimiter)
/**
@version egbs-sparafiler.qwv $Revision$  $Author$ 
Store-procedyr for att spara en CSV-formaterad fil med .TXT eller .CSV ändelse.
Spar ned till CSV-formaterad fil och (evt. droppar) tabell .
Spar ned metadata om filen till tabell egbs.ListOutputFiles
@syntax CALL egbs.StoreCSV(Tabell, [Output], [_dropTable], [_delimiter])
@syntax CALL egbs.StoreCSV('Transaktioner', '$(vG.QVDPath)', [_dropTable], [_delimiter])
@syntax CALL egbs.StoreCSV('Transaktioner', '$(vG.QVDPath)Mina.Transaktioner.csv', -1, [_delimiter])
@syntax CALL egbs.StoreCSV('Transaktioner', '$(vG.QVDPath)Mina.Transaktioner.txt', -1, '\t')
@param 1 Tabellnamn i datamodellen
@param 2 Valfri - Sökväg där csv-fil blir sparad. Default är applikationssökväg.
@param 3 Valfri - Ange '-1' om tabellen ska droppas efter Store.
@param 4 Valfri - Fältseparator. Defaultvärde är ';'. Ange '\t' för tabb-separerad.
@changelog 2013-02-28 Vegar #48 Skapat sub som sparar till CSV
@changelog 2013-04-24 Magnus Lagt till fullständigt filnamn i outputtabellen.
@changelog 2013-04-24 Vegar Lagt till EGBS-SUB-loggingtransaktioner i flödet.
@changelog 2015-05-20 Magnus Justerat logiken för att hantera dubbla backslash i sökvägen, samt lagt till parametern _delimiter 
@changelog 2018-07-27 Vegar Tar bort beroenden till andra egbs-components qvs-filer genom att byta från egbs.log till TRACE;
*/
IF '$(_output)' = '' THEN 
	SET _output = '.\$(_table).csv';
ELSEIF RIGHT('$(_output)',1) = '\' THEN
	SET _output = '$(_output)$(_table).csv';
ELSEIF MATCH(RIGHT(UPPER(_output),4),'.CSV','.TXT') = 0 THEN
	SET _output = '$(_output)\$(_table).csv';
ENDIF

// Sätt default delimiter if not set
IF '$(_delimiter)' = '' THEN
	SET _delimiter = ';';
ENDIF
// Spara filen
Store [$(_table)] into [$(_output)] (txt, delimiter is '$(_delimiter)');
// Fyller outputtabelll med metadata om den sparade txt-filen.
CALL _egbs.ListOutputFile( '$(_table)', '$(_output)', "(txt, utf8, embedded labels, delimiter is '$(_delimiter)', msq)" )

// Ta eventuellt bort filen
If '$(_dropTable)' = '-1' then
	drop table [$(_table)];
ENDIF
// Logga sparandet i egbs log
TRACE # egbs-components: Saved table $(_table) to $(_output).;
// Clear variables before end of function
SET _output=;
SET _table=;
SET _dropTable=;
SET _delimiter=;

ENDSUB
/* * End SUB egbs.StoreCSV * */

///$tab egbs.StoreQVDs
SUB egbs.StoreQVDs(_outputPath,_StoreFilter,_StoreFilterExclude)
/**
@version egbs-sparafiler.qwv $Revision$  $Author$ 
Loopar igenom och spar undan alla tabeller i datamodellen som fångas upp av givna inkludera/exkludera-filter. Default sparas alla RESIDENTtabeller ned.
@syntax CALL egbs.StoreQVDs([_outputPath], [_StoreFilter], [_StoreFilterExclude])
@param 1 Valfri. _outputPath Sökväg till där QVD:er ska sparas. Default är .\
@param 2 Valfri. _StoreFilter Filter för vilka tabeller som ska sparas. Eg: 'Dim?,Transaktioner' ELLER 'Dim1, Dim3'
@param 3 Valfri. _StoreFilterExclude Filter för vilka tabeller som ska INTE ska sparas.  Eg: 'Dim2,Transaktioner' ELLER 'Dim?'

@changelog 2013-04-24 Magnus Lagt till fullständigt filnamn i outputtabellen.
@changelog 2013-04-24 Vegar Ändrat så att egbs.StoreQVDs visar korrekt parameterinformation i dokumentationen.
@changelog 2015-05-21 Magnus BRYTER BAKÅTKOMPABILITET. Ändrat ordning på parametrarna, så att outputPath kommmer först.
@changelog 2018-07-27 Vegar Tar bort beroenden till andra egbs-components qvs-filer genom att byta från egbs.log till TRACE;
*/
_egbs.v.StoreAllToQVD.handledTables = 0;
_StoreFilter = IF(LEN(_StoreFilter)=0,chr(39)&'*'&chr(39),chr(39)&replace(_StoreFilter,',',chr(39)&','&chr(39))&chr(39));
_StoreFilterExclude = chr(39)&replace(_StoreFilterExclude,',',chr(39)&','&chr(39))&chr(39);

IF '$(_outputPath)' = '' THEN 
	SET _outputPath = '.\'; 
ENDIF
Do WHILE _egbs.v.StoreAllToQVD.handledTables <  NoOfTables() 
	//Gällande tabellnamn
	let _egbs.v.StoreAllToQVD.TableName = TableName('$(_egbs.v.StoreAllToQVD.handledTables)');
	
	//Filter
	if WildMatch(_egbs.v.StoreAllToQVD.TableName,$(_StoreFilter)) > 0 AND  WildMatch(_egbs.v.StoreAllToQVD.TableName,$(_StoreFilterExclude)) = 0 THEN
		STORE [$(_egbs.v.StoreAllToQVD.TableName)] INTO $(_outputPath)$(_egbs.v.StoreAllToQVD.TableName).qvd (qvd);
		TRACE # egbs-components: Tabellen $(_egbs.v.DropAllTables.TableName) sparat som $(_outputPath)$(_egbs.v.StoreAllToQVD.TableName).qvd.;

		//Fyller outputtabell med metadata om den sparade qvd-filen.
		CALL _egbs.ListOutputFile( '$(_egbs.v.StoreAllToQVD.TableName)','$(_outputPath)$(_egbs.v.StoreAllToQVD.TableName).qvd','(qvd)')
	else 
		TRACE # egbs-components: Tabellen $(_egbs.v.StoreAllToQVD.TableName) har exkluderats av filter;
	ENDIF
	LET _egbs.v.StoreAllToQVD.handledTables = _egbs.v.StoreAllToQVD.handledTables + 1;
	//TRACE # egbs-components: Saved table $(_egbs.v.DropAllTables.TableName) to $(_outputPath)$(_egbs.v.StoreAllToQVD.TableName).qvd.;

Loop // Tableloop
// Clear Variables
SET _egbs.v.StoreAllToQVD.keptTables=;
SET _egbs.v.StoreAllToQVD.TableName =;
SET _StoreFilter=;
SET _StoreFilterExclude=;
SET _outputPath=;
SET _egbs.v.StoreAllToQVD.handledTables=;

//call egbs.Log('egbs.StoreQVDs','EGBS-SUB')

END SUB

/* * End of sub StoreAllToQVD * */
///$tab _egbs.ListOutputFile
SUB _egbs.ListOutputFile (_Table, _File, _FileFormat)
	/**
	@version egbs-sparafiler.qwv $Revision$  $Author$ 
	Spar ned metadata från fil och tillhörande tabell - egbs.OutputFiles. 
	Används primärt av StoreQvd och StoreTxt-funktionerna.
	@syntax CALL  CALL _egbs.ListOutputFile( 'ASCII', 'ASCII-tabell.qvd', '(qvd)' )
	@Param 1 Namn på residenttabell
	@Param 2 Namn på fil
	@Param 3 Filformat, hur filen ska tolkas. Eg. (txt, utf8, embedded labels, delimiter is ';', msq)
	@changelog 2013-02-28 Vegar #46 Ändrat så att output-värden till tabellen OutputFiles inte läser FIRST 1 LOAD från fil, men i stället använder sig av funktioner som tar fil som input eller de parametrar som ropar på subben.
	@changelog 2013-02-28 Vegar Tog bort errorhantering för fil-saknas då vi numera inte läser filen.
	@changelog 2022-01-20 Magnus Hantera LIB och / i sökvägar som används i Qlik Sense.
	*/
	IF UPPER(Left('$(_File)',3)) = 'LIB' THEN
		SET _separator = '/';		
	ELSE
		SET _separator = '\';
	ENDIF

	egbs.OutputFiles:
	LOAD
		Replace('$(_File)', SubField('$(_File)','$(_separator)', SubStringCount('$(_File)','$(_separator)')+1) ,'') as [File Path],
		FileTime('$(_File)') as [File Time],
		NoOfFields('$(_Table)')as [No of fields],
		NoOfRows('$(_Table)') as [No Of records],
		FileSize('$(_File)') as [File size (Bytes)],
		SubField('$(_File)','$(_separator)', SubStringCount('$(_File)','$(_separator)')+1)  as [File],
		mid('$(_File)', Index('$(_File)', '$(_separator)', -1) + 1, Index('$(_File)','.',-1) - Index('$(_File)','$(_separator)',-1) -1) as [File name],
		mid('$(_File)', Index('$(_File)', '.', -1) + 1, Index('$(_File)', '.', -1) - Index('$(_File)', '$(_separator)', -1) -1) as [File extension]
	AutoGenerate 1 
	;

	SET _separator =;
ENDSUB
///$tab End
REM ===== avsluta egbs-components.qvs export =====;
///$tab egbs-Timer	
/*

**** Comments ****
===================================================
Date		User	Description
===================================================
@changelog 2015-10-12 MASV Skapat första versionen.
@changelog 2018-07-26 Vegar Anpassat så att egbs-timer-funktionerna är oberoende av andra components qvs-filer.
*/

REM ===== starta egbs-components.qvs export =====;

// Functions to measure execution time of functions
SUB egbs.InitTimer
/**
	@version egbs-Timer.qwv
	Initieringsfunktion för timer-funktionalitet. Skall anropas först i scriptet.
	Behövs för att använda funktionerna StartTimer, StopTimer, FinishTimer
	
	Timerfunktionerna skapar en tidslogg per tagg.
	Resultatet är en tabell med starttid, sluttid och tidsåtgång per körning och tagg.
	Resultatet kan sparas över flera dagar, samt sparas ner till fil.
	
	Timerfunktioner(egbs.InitTimer, egbs.StartTimer, egbs.StopTimer, egbs.FinishTimer)

	@syntax CALL egbs.InitTimer
	@var egbs.vL.Timer.InitTag in String. Init tag in timer log. Default is 'Script'.
	@changelog 2015-10-12 Magnus Ny funktion: egbs.InitTimer. Tillhör Timerfunktionalitet (egbs.InitTimer, egbs.StartTimer, egbs.StopTimer, egbs.FinishTimer)
	
*/
	// Init Counters
	SET _vL.Timer.TimerCounter = 0;
	SET _vL.Timer.LevelCounter = 0;
	
	// Init TagPath
	CALL _egbs.timer.setEmptyVariable('egbs.vL.Timer.InitTag','Script')
	SET _vL.Timer.TagPath = '$(_vL.Timer.TimerCounter).$(egbs.vL.Timer.InitTag)';
	
	// Execution Timestamp - Used to group a time to a special run
	LET _vL.Timer.RunTimeStamp = now(1);
	
	// Document Name
	LET _vL.Timer.DocumentName = DocumentName();
	
	tmpTimer:
	LOAD
		'$(_vL.Timer.DocumentName)' as Timer.DocumentName,
		'$(_vL.Timer.RunTimeStamp)' as Timer.RunTimeStamp,
		'$(_vL.Timer.TimerCounter)' as Timer.TimerCounter,
		'$(_vL.Timer.TagPath)' as Timer.TagPath,
		'$(_vL.Timer.LevelCounter)' as Timer.Level,
		'Script' as Timer.Tag,
		'Init timer' as Timer.Comment,		
		now(1) as Timer.TimeStamp,
		now(1) as Timer.Start
	AUTOGENERATE 1
	;	
ENDSUB  //InitTimer

SUB egbs.StartTimer(_vL.Timer.Tag, _vL.Timer.Comment)
/**
	@version egbs-Timer.qwv
	Start för timer-funktionalitet. Sätter ingång en tidsräknare kopplad till en tag.
	Funktionen InitTimer måste ha körts först.
	
	Timerfunktionerna skapar en tidslogg per tagg.
	Resultatet är en tabell med starttid, sluttid och tidsåtgång per körning och tagg.
	Resultatet kan sparas över flera dagar, samt sparas ner till fil.
	
	Timerfunktioner(egbs.InitTimer, egbs.StartTimer, egbs.StopTimer, egbs.FinishTimer)
		
	@syntax CALL egbs.StartTimer(['<Timer Tag>'],['<Comment>'])
	@param 1 Textsträng. Timer tag. Valfri informationstext. Om det utelämnas sätts texten Timer_<Counter>.<Level>.
	@param 2 Valfri Textsträng. Kommentarsfält.
	
	@changelog 2015-10-12 Magnus Ny funktion: egbs.StartTimer. Tillhör Timerfunktionalitet (egbs.InitTimer, egbs.StartTimer, egbs.StopTimer, egbs.FinishTimer)
*/
	LET _vL.Timer.TimerCounter = _vL.Timer.TimerCounter + 1;
	LET _vL.Timer.LevelCounter = _vL.Timer.LevelCounter + 1;
	
	CALL _egbs.timer.setEmptyVariable('_vL.Timer.Tag','Timer_$(_vL.Timer.TimerCounter).$(_vL.Timer.LevelCounter)')
	LET _vL.Timer.TagPath = '$(_vL.Timer.TagPath)\$(_vL.Timer.TimerCounter).$(_vL.Timer.Tag)';
	
	Concatenate(tmpTimer)
	LOAD
		'$(_vL.Timer.DocumentName)' as Timer.DocumentName,
		'$(_vL.Timer.RunTimeStamp)' as Timer.RunTimeStamp,
		'$(_vL.Timer.TimerCounter)' as Timer.TimerCounter,
		'$(_vL.Timer.TagPath)' as Timer.TagPath,
		'$(_vL.Timer.LevelCounter)' as Timer.Level,
		'$(_vL.Timer.Tag)' as Timer.Tag,
		'$(_vL.Timer.Comment)' as Timer.Comment,
		now(1) as Timer.TimeStamp,
		now(1) as Timer.Start
	AUTOGENERATE 1
	;

	SET _vL.Timer.Tag =;
	SET _vL.Timer.Comment =;	
ENDSUB //egbs.StartTimer

SUB egbs.StopTimer
/**
	@version  egbs-Timer.qwv
	Stopp för timer-funktionalitet. Kopplar ihop en stopptid med en starttid för aktuell tag.
	
	Timerfunktionerna skapar en tidslogg per tagg.
	Resultatet är en tabell med starttid, sluttid och tidsåtgång per körning och tagg.
	Resultatet kan sparas över flera dagar, samt sparas ner till fil.
	
	Timerfunktioner(egbs.InitTimer, egbs.StartTimer, egbs.StopTimer, egbs.FinishTimer)
		
	@syntax CALL egbs.StopTimer
	@changelog 2015-10-12 Magnus Ny funktion: egbs.StopTimer. Tillhör Timerfunktionalitet (egbs.InitTimer, egbs.StartTimer, egbs.StopTimer, egbs.FinishTimer)
*/	
	tmpEndLog:
	LOAD
		'$(_vL.Timer.RunTimeStamp)' as Timer.RunTimeStamp, // Join
		'$(_vL.Timer.TagPath)' as Timer.TagPath, // Join
		now(1) as Timer.Stop
	AUTOGENERATE 1
	;

	LET _vL.Timer.LevelCounter = _vL.Timer.LevelCounter - 1;
	LET _vL.Timer.TagPath = Left('$(_vL.Timer.TagPath)',Index('$(_vL.Timer.TagPath)','\',-1)-1);

ENDSUB //egbs.StopTimer

SUB egbs.FinishTimer(_vL.Timer.KeepDays, _vL.Timer.DropTable)
	/**
	@version  egbs-Timer.qwv
	Avslutsfunktion för timer-funktionalitet. Skall anropas sist i scriptet.
	Kräver att funktionen InitTimer har körts.
	Sparar timer loggen och sparar den eventuellt till fil.
	
	Timerfunktionerna skapar en tidslogg per tagg.
	Resultatet är en tabell med starttid, sluttid och tidsåtgång per körning och tagg.
	Resultatet kan sparas över flera dagar, samt sparas ner till fil.
	
	Timerfunktioner(egbs.InitTimer, egbs.StartTimer, egbs.StopTimer, egbs.FinishTimer)
	
	@syntax CALL egbs.FinishTimer
	@syntax CALL egbs.FinishTimer([1])
	@syntax CALL egbs.FinishTimer([7],[-1])
	@param 1 Valfri integer. Antal dagar som historik skall sparas.
	@param 2 Valfri -1. Om -1 anges så tas den lokala tabellen egbs.Timer bort.
	@var egbs.vL.Timer.FileName in String. Loggfilens namn. Standardvärde är "<Dokumentnamn>_Timer.txt"
	@var egbs.vL.Timer.Table in String. Loggtabellens namn. Standardvärde är "egbs.TimerTable"
	@changelog 2015-10-12 Magnus Ny funktion: egbs.FinishTimer. Tillhör Timerfunktionalitet (egbs.InitTimer, egbs.StartTimer, egbs.StopTimer, egbs.FinishTimer)
	*/
	// Set varible for keeping history
	CALL _egbs.timer.setEmptyVariable('egbs.vL.Timer.KeepDays','0')	
	IF IsNum('$(_vL.Timer.KeepDays)') then
		LET egbs.vL.Timer.KeepDays  = Alt(Num#($(_vL.Timer.KeepDays)),0);
	ENDIF

	// Timer Log filename
	CALL _egbs.timer.setEmptyVariable('egbs.vL.Timer.FileName','.\'&left(DocumentName(), index(DocumentName(),'.',-1)-1) & '_TimerLog.txt')

	// Timer Log Tablename
	CALL _egbs.timer.setEmptyVariable('egbs.vL.Timer.Table','egbs.Timer')

	// Finish Init start time tag	
	tmpEndLog:
	LOAD
		'$(_vL.Timer.RunTimeStamp)' as Timer.RunTimeStamp, // Join
		'$(_vL.Timer.TagPath)' as Timer.TagPath, // Join
		now(1) as Timer.Stop
	AUTOGENERATE 1
	;

	Left Join(tmpTimer)
	LOAD * Resident tmpEndLog;
	DROP Table tmpEndLog;

	// Beräknad tidsåtgång
	[$(egbs.vL.Timer.Table)]:
	LOAD
		*,
		Interval(Timer.Stop - Timer.Start) as Timer.Duration
	Resident tmpTimer;
	DROP Table tmpTimer;

	// Lägg eventuellt till historik om det finns
	IF $(egbs.vL.Timer.KeepDays) > 0 THEN		// If requested to keep previous logs...
		IF $(_egbs.FileExists('.\$(egbs.vL.Timer.FileName)')) THEN	// and we haven't loaded it
			Concatenate([$(egbs.vL.Timer.Table)])
			LOAD 
				Timer.DocumentName,
				Timer.RunTimeStamp, 
				Timer.TagPath, 
				Timer.TimerCounter, 
				Timer.Level, 
				Timer.Tag, 
				Timer.Comment,
				Timer.TimeStamp, 
				Timer.Start, 
				Timer.Stop,
				Interval(Timer.Duration) as Timer.Duration
			FROM
			[$(egbs.vL.Timer.FileName)]
			(txt, utf8, embedded labels, delimiter is ',', msq)
			Where Floor(Timer.RunTimeStamp) >= Today(1) - $(egbs.vL.Timer.KeepDays) // Only lines within the history limit
			;
		ENDIF
	ENDIF			

	LET _vL.Timer.LevelCounter = _vL.Timer.LevelCounter - 1;
	LET _vL.Timer.TagPath = Left('$(_vL.Timer.TagPath)',Index('$(_vL.Timer.TagPath)','\',-1)-1);

	// Spara eventuellt loggen till en textfil
	IF $(egbs.vL.Timer.KeepDays) > 0 THEN
		STORE [$(egbs.vL.Timer.Table)] into [$(egbs.vL.Timer.FileName)] (txt);
	ENDIF
	
	// Ta eventuellt bort tabellen
	IF '$(_vL.Timer.DropTable)' = '-1' then
		DROP Table [$(egbs.vL.Timer.Table)];
	ENDIF

	// Clear variables
	SET egbs.vL.Timer.FileName =;
	SET egbs.vL.Timer.KeepDays =;
	SET egbs.vL.Timer.Table =;
	SET egbs.vL.Timer.FileName =;
	SET egbs.vL.Timer.InitTag =;
	SET _vL.Timer.TimerCounter =;
	SET _vL.Timer.LevelCounter =;
	SET _vL.Timer.TagPath =;
	SET _vL.Timer.RunTimeStamp =;
	SET _vL.Timer.DocumentName =;

ENDSUB




///$tab _egbs.timer.setEmptyVariable
SUB _egbs.timer.setEmptyVariable(_var, _default)
	/**
	@version egbs-verktyg.qwv $Revision$  $Author$
	Sätter defaultvärde på variabel så länge den inte är förhandsdefinierad i scriptet t.ex via språk/anpassnings-includes.
	@syntax CALL _egbs.timer.setEmptyVariable('Var1', 'Defaultvärde 1')
	@param 1 Textstreng. Namn på variabel som ska sättas värde på. 
	@param 2 Textstreng. Defaultvärdet på variabeln.
	@var <Parameter 1> ut Returnerar variabeln deklarerad som paramteter 1 med befintligt eller defaultvärde

	*/
	LET $(_var) = if(len($(_var))=0, _default, $(_var));
ENDSUB
REM ===== avsluta egbs-components.qvs export =====;
// EGBS.VERKTYG INNEHÅLLER
//
// SUB
// - egbs.StartScript
// - egbs.EndScript
// - egbs.Cleanup

// FUNCTION
// - egbs.TableExists
// - egbs.FieldExists
// 
SUB egbs.StartScript
/**
@version $Id$
Sätter nödvändiga startvariabler för att göra skriptexekveringsuppsummering. Används tillsammans med egbs.EndScript.
@syntax CALL egbs.StartScript
@var egbs.vL.StartTime ut Tid då egbs.StartScript blev anropt.
*/
	LET egbs.vL.StartTime = now();
ENDSUB

SUB egbs.EndScript
/**
@version $Id$
Gör exekveringstiduppsummering och avslutar scriptet. Ska användas tillsammans med egbs.StartScript. Sammanställer laddtider i tabellen egbs.LoadTimes.
@syntax CALL egbs.EndScript
@var egbs.vL.StartTime in Tid då egbs.StartScript blev anropt.
*/
	LET _egbs.vEndTime = now();
	LET _egbs.vLoadTime = time( _egbs.vEndTime - egbs.vL.StartTime);

	egbs.LoadTimes:
	LOAD
		'$(egbs.vL.StartTime)' as egbs.StartTime,
		'$(_egbs.vEndTime)' as egbs.EndTime,
		'$(_egbs.vLoadTime)' as egbs.LoadTime
	Autogenerate 1;
	
	// Clear variables
	LET egbs.vL.StartTime = ;
	LET _egbs.vEndTime = ;
	LET _egbs.vLoadTime = ;
	
	Exit script;
ENDSUB

SUB egbs.Cleanup
/**
@version $Id$
Städar upp efter egbs-sub-skripet.

@syntax CALL egbs.Cleanup
@VAR egbs.TableExists ut Nollställer funktions-variabeln
@VAR egbs.FileExists ut Nollställer funktions-variabeln

@changelog 2018-07-30 Vegar Tagit bort alla Log-variabler då de inte längre längre ingår i EGBS components.
@changelog 2018-07-30 BRYTER BAKÅTKOMPABILITET egbs.cleanup ersätts delvis av egbs.CalendarCleanup och egbs.GetExpressionsCleanup beroende på om det är variabler från calendar eller getexpressions som ska hanteras. egbs.cleanup finns kvar och kan användas om den koplierade versionen egbs.qvs används, men kan inte användas om endast egbs-calendar.qvs eller egbs-getexpressions.qvs inkluderas i scriptet.  
*/
//FUNKTIONER
	call egbs.calendarcleanup ;
	call egbs.GetExpressionsCleanup;
	LET egbs.FileExists=NULL();
	LET egbs.TableExists=NULL();
ENDSUB


///$tab Functions
/** 
Inte supporterat / produktionsatt i egbs-components används endast internt i qvs
@Function egbs.TableExists
@version egbs-verktyg.qvs
Funktion som returnerar true om tabell existerar
@syntax LET v.TableExists = $(_egbs.TableExists(tabell));
@param 1 Tabellnamn. NB: inga situationstecken ''.

@changelog 2018-07-30 Vegar Lagt till ny funktion egbs.TableExists. Den har varit en dold funktion som nu lyfts fram.
*/
SET egbs.TableExists = Len(NoOfRows('$1'))>0;
/*
@EndFunction
*/

/** 
Inte supporterat / produktionsatt i egbs-components används endast internt i qvs
@Function egbs.FileExists
@version egbs-verktyg.qvs
Funktion som returerar true om en fil existerar. This function may only be used in script.
@syntax LET vExists = $(_egbs.FileExists('dir\filename.ext'));
@param 1 The relative or absolute file path as string.

@changelog 2018-07-30 Vegar Lagt till ny funktion egbs.FileExists. Den har varit en dold funktion som nu lyfts fram.

*/
SET egbs.FileExists = if(len(FileSize($1)) > 0, -1, 0);
/*
@EndFunction
*/
REM ===== avsluta egbs-components.qvs export =====;
